<!--
 * @Description: In User Settings Edit
 * @Author: your name
 * @Date: 2019-04-08 15:48:33
 * @LastEditTime: 2019-07-29 15:25:54
 * @LastEditors: Please set LastEditors
 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        //object.defineProperty()会直接在一个对象上定义一个新属性，或者修改一个对象的洗有苏醒，并返回这个对象。
        // 语法
        // Object.defineProperty (obj, prop, descriptor)
        // 参数
        // obj 要在其上定义属性的对象
        // prop 要定义或修改的属性的名称
        // descriptor 要定义或修改的属性描述符

        // 返回值  被传递给函数的对象

        // 在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，
        // 而Object.defineProperty 是定义key为Symbol的属性的方法之一。

        // 该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（for...in 或 Object.keys 方法）， 
        // 这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 
        // 添加的属性值是不可修改的


        // https://www.cnblogs.com/zhangrunhao/p/7660931.html
        var obj = {};
        Object.defineProperty(obj, 'key', {
            enumerable: false, //当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。
            configurable: false, //当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。
            writable: false, //当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。
            value: 'static' //该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。
        })

        Object.defineProperty(obj, 'key', {
            enumerable: false, //当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。
            configurable: false, //当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。
            get: function () { // 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。
                return bValue;
            },
            set: function (
            newValue) { //一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。 
                bValue = newValue;
            },
        })
        // get/set不必成对出现, 任写其一就可以. 如果设置不方便, 则get和set的默认值为undeifend


        // 一旦使用Objec.defineProperty给对象添加属性, 如果不设置属性的话, 那么configuable, enumerable, writable这些都是默认的false
        // 不能被枚举, 不能被重写, 不能被再次更改属性

        // 当使用了getter或者setter方法, 不允许使用writable和value这两个属性
        // 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。
        // 存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。


        // 兼容性
        // 在IE8下只能对DOM对象使用, 如果对原生对象使用Object.defineProtry()会报错



        var o = {}; // Creates a new object

        Object.defineProperty(o, 'a', {
            value: 37,
            writable: false
        });

        console.log(o.a); // logs 37
        o.a = 25; // No error thrown
        // o[a]=26;
        // (it would throw in strict mode,
        // even if the value had been the same)
        console.log(o.a); // logs 37. The assignment didn't work.

        console.log("--------------------------------------------------------------------------");
        // Object.defineProperty 监听对象属性变化
        let obj0 = {}
        let value = ''
        Object.defineProperty(obj0, 'name', {
            get: () => {
                return value
            },
            set: (newVal) => {
                console.log('检测到变化', newVal);
                value = newVal;
            }
        })
        console.log(obj0.name, '     1:')
        obj0.name = 'mfg'
        console.log(obj0.name, '     2:')

        console.log("--------------------------------------------------------------------------");
        // 一。了解Symbol   http://es6.ruanyifeng.com/#docs/symbol



        // 每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。
        let s = Symbol();

        typeof s
        console.log(typeof s); // "symbol"

        // Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，
        // 且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法："new Symbol()"。

        // 这会阻止创建一个显式的 Symbol 包装器对象而不是一个 Symbol 值。围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 
        // 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number因为遗留原因仍可被创建。

        // 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。
        // 也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。


        //这样就会重写属性
        var a = {
            name: 'lucy'
        };
        a.name = 'lili';
        console.log(a.name);


        // 没有参数的情况
        var s1 = Symbol();
        var s2 = Symbol();
        s1 === s2 // false               //它每次都会创建一个新的 symbol类型
        console.log(s1 === s2); // false
        console.log(s1); //Symbol()
        console.log(s2); //Symbol()

        // 有参数的情况 1 字符串    Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，
        // 主要是为了在控制台显示，或者转为字符串时，比较容易区分。
        var s1 = Symbol("foo");
        var s2 = Symbol("foo");
        s1 === s2 // false
        console.log(s1 === s2); // false
        console.log(s1); //Symbol(foo)
        console.log(s2); //Symbol(foo)

        // 2 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。

        const obj = {
            toString() {
                return 'abc';
            }
        };
        const sym = Symbol(obj);
        sym // Symbol(abc)


        // Symbol 值不能与其他类型的值进行运算，会报错。

        let syms = Symbol('My symbol');

        "your symbol is " + syms
        // TypeError: can't convert symbol to string
        `your symbol is ${syms}`
        // TypeError: can't convert symbol to string
        // 但是，Symbol 值可以显式转为字符串。

        let symss = Symbol('My symbol');

        String(symss) // 'Symbol(My symbol)'
        symss.toString() // 'Symbol(My symbol)'
        // 另外，Symbol 值也可以转为布尔值，但是不能转为数值。

        let symsss = Symbol();
        Boolean(symsss) // true`
            !symsss // false

        if (symsss) {
            // ...
        }

        Number(symsss) // TypeError
        symsss + 2 // TypeError

        // 二. 作为属性名的Symbol

        var mySymbol = Symbol();

        // 第一种写法
        var a = {};
        a[mySymbol] = 'Hello!';

        // 第二种写法
        var a = {
            [mySymbol]: 'Hello!'
        };

        // 第三种写法
        var a = {};
        Object.defineProperty(a, mySymbol, {
            value: 'Hello!'
        });

        // 以上写法都得到同样结果
        a[mySymbol] // "Hello!"
        console.log(a[mySymbol]); // "Hello!"

        //注意，Symbol值作为对象属性名时，不能用点运算符。
        var b = {};
        var names = Symbol();
        b.names = 'lili';
        b[names] = 'lucy';
        b['names'] = 'lucy666';
        console.log(b.names, b[names], b['names']); //lili,lucy lucy666
        // 上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，
        // 导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。


        // 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。

        let s3 = Symbol();

        let obj1 = {
            [s3]: function (arg) {
                return arg + 1
            }
        };

        obj[s3](123);
        // 上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。

        // 采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。

        let obj2 = {
            [s3](arg) {
                return arg + 1
            }
        };




        //Symbol值作为属性名时，该属性还是公开属性，不是私有属性。
        //这个有点类似于java中的protected属性（protected和private的区别：在类的外部都是不可以访问的，在类内的子类可以继承protected不可以继承private）

        //但是这里的Symbol在类外部也是可以访问的，只是不会出现在for...in、for...of循环中，
        // 也不会被Object.keys()、Object.getOwnPropertyNames()返回。但有一个Object.getOwnPropertySymbols方法，
        // Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
        {
            const obj = {};
            let a = Symbol('a');
            let b = Symbol('b');

            obj[a] = 'Hello';
            obj[b] = 'World';

            const objectSymbols = Object.getOwnPropertySymbols(obj);

            objectSymbols
            // [Symbol(a), Symbol(b)]
        }

        // 可以获取指定对象的所有Symbol属性名
        {
            const obj = {};

            let foo = Symbol("foo");

            Object.defineProperty(obj, foo, {
                value: "foobar",
            });

            for (let i in obj) {
                console.log(i); // 无输出
            }

            Object.getOwnPropertyNames(obj)
            // []

            Object.getOwnPropertySymbols(obj)
            // [Symbol(foo)]
        }

        // 另一个新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。
        {
            let obj = {
                [Symbol('my_key')]: 1,
                enum: 2,
                nonEnum: 3
            };

            Reflect.ownKeys(obj)
        }

        //  ["enum", "nonEnum", Symbol(my_key)]
        //三。Symbol.for()，Symbol.keyFor()
        // Symbol.for机制有点类似于单例模式，首先在全局中搜索有没有以该参数作为名称的Symbol值，
        // 如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。和直接的Symbol就点不同了。

        var s1 = Symbol.for('foo');
        var s2 = Symbol.for('foo');

        s1 === s2 // true
        // Symbol.keyFor方法返回一个已登记的Symbol类型值的key。实质就是检测该Symbol是否已创建

        var s1 = Symbol.for("foo");
        Symbol.keyFor(s1) // "foo"

        var s2 = Symbol("foo");
        Symbol.keyFor(s2) // undefined
    </script>
</body>

</html>