<!--
 * @Author              : qxp
 * @Date                : 2021-03-22 16:51:07
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-03-22 16:59:44
 * @FilePath            : \new\6 Es6\5 扩展\5对象的新增方法 .html
-->
1 Object.is()

```js
    Object.is('foo', 'foo')
    // true
    Object.is({}, {}) +
        // false
        // 不同之处只有两个：一是 + 0不等于 - 0，二是NaN等于自身。

        0 ===
        -0 //true
    NaN === NaN // false

    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true
    // ES5 可以通过下面的代码，部署Object.is。

    Object.defineProperty(Object, 'is', {
        value: function (x, y) {
            if (x === y) {
                // 针对+0 不等于 -0的情况
                return x !== 0 || 1 / x === 1 / y
            }
            // 针对NaN的情况
            return x !== x && y !== y
        },
        configurable: true,
        enumerable: false,
        writable: true,
    })
```
2 Object.assign()
```js
    const target = { a: 1 }
    const source1 = { b: 2 }
    const source2 = { c: 3 }

    Object.assign(target, source1, source2)
    target // {a:1, b:2, c:3}
    // Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象
    //（1) Object.assign()方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。

    const obj1 = { a: { b: 1 } }
    const obj2 = Object.assign({}, obj1)

    obj1.a.b = 2
    obj2.a.b // 2
    // （2）同名属性的替换
    // 对于这种嵌套的对象，一旦遇到同名属性，Object.assign()的处理方法是替换，而不是添加。

    const target = { a: { b: 'c', d: 'e' } }
    const source = { a: { b: 'hello' } }
    Object.assign(target, source)
    // { a: { b: 'hello' } }
```

3 __proto__属性 该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了
ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性 


4 Object.setPrototypeOf() 写操作 
5 Object.getPrototypeOf() 读操作 
6 Object.create() （生成操作） 
7 Object.keys()，Object.values()，
```js
    const obj = { foo: 'bar', baz: 42 }
    Object.entries(obj)
    // [ ["foo", "bar"], ["baz", 42] ]

    // Object.entries方法的另一个用处是，将对象转为真正的Map结构。

    const obj = { foo: 'bar', baz: 42 }
    const map = new Map(Object.entries(obj))
    map // Map { foo: "bar", baz: 42 }
    // 自己实现Object.entries方法，非常简单。

    // Generator函数的版本
    function* entries(obj) {
        for (let key of Object.keys(obj)) {
            yield [key, obj[key]]
        }
    }

    // 非Generator函数的版本
    function entries(obj) {
        let arr = []
        for (let key of Object.keys(obj)) {
            arr.push([key, obj[key]])
        }
        return arr
    }
```

8 Object.fromEntries(),Object.entries()
```js
    // Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。
    Object.fromEntries([
        ['foo', 'bar'],
        ['baz', 42]
    ])
    // { foo: "bar", baz: 42 }

    // 1 Map 转化为 Object
    通过 Object.fromEntries， 可以将 Map 转换为 Object:

    const map = new Map([ ['foo', 'bar'], ['baz', 42] ]);
    const obj = Object.fromEntries(map);
    console.log(obj); // { foo: "bar", baz: 42 }
    // 2 Array 转化为 Object
    //  通过 Object.fromEntries， 可以将 Array 转换为 Object:

    const arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];
    const obj = Object.fromEntries(arr);
    console.log(obj); // { 0: "a", 1: "b", 2: "c" }
    // 3 对象转换
    // Object.fromEntries 是与 Object.entries() 相反的方法，用 数组处理函数 可以像下面这样转换对象：
    const object1 = { a: 1, b: 2, c: 3 };
    const object2 = Object.fromEntries(
    Object.entries(object1)
    .map(([ key, val ]) => [ key, val * 2 ])
    );
    console.log(object2);
    // { a: 2, b: 4, c: 6 }


    // Object.entries()

    const obj = { foo: 'bar', baz: 42 };
    console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]

    // array like object
    const obj = { 0: 'a', 1: 'b', 2: 'c' };
    console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]

    // array like object with random key ordering
    const anObj = { 100: 'a', 2: 'b', 7: 'c' };
    console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]

    // getFoo is property which isn't enumerable
    const myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });
    myObj.foo = 'bar';
    console.log(Object.entries(myObj)); // [ ['foo', 'bar'] ]

    // non-object argument will be coerced to an object
    console.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]

    // iterate through key-value gracefully
    const obj = { a: 5, b: 7, c: 9 };
    for (const [key, value] of Object.entries(obj)) {
    console.log(`${key} ${value}`); // "a 5", "b 7", "c 9"
    }

    // Or, using array extras
    Object.entries(obj).forEach(([key, value]) => {
    console.log(`${key} ${value}`); // "a 5", "b 7", "c 9"
    });
```
