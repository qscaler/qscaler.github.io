<!--
 * @Author              : qxp
 * @Date                : 2021-03-22 16:34:31
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-03-22 16:48:03
 * @FilePath            : \new\6 Es6\5 扩展\4 对象的扩展.html
-->

一 属性名表达式
<script>
    const foo = 'bar';
    const baz = { foo };
    baz // {foo: "bar"}

    // 等同于
    const baz = { foo: foo };
    // 上面代码中，变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值
</script>


<script>
    function f(x, y) {
        return { x, y };
    }

    // 等同于
    function f(x, y) {
        return { x: x, y: y };
    }
    f(1, 2) // Object {x: 1, y: 2}
</script>

<script>
    // 除了属性简写，方法也可以简写。
    const o = {
        method() {
            return "Hello!";
        }
    };

    // 等同于
    const o = {
        method: function () {
            return "Hello!";
        }
    };
</script>

<script>

    // 简洁写法在打印对象时也很有用。
    let user = {
        name: 'test'
    };

    let foo = {
        bar: 'baz'
    };

    console.log(user, foo)
    // {name: "test"} {bar: "baz"}
    console.log({ user, foo })
    // {user: {name: "test"}, foo: {bar: "baz"}}
</script>


二 属性名表达式

<script>
    // ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。
    let propKey = 'foo';

    let obj = {
        [propKey]: true,
        ['a' + 'bc']: 123
    };
</script>
三 方法的 name 属性
<script>
    // 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
    const person = {
        sayName() {
            console.log('hello!');
        },
    };

    person.sayName.name // "sayName"
</script>

四 属性的可枚举性和遍历

<script>
    // 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。
    // Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。

    let obj = { foo: 123 };
    Object.getOwnPropertyDescriptor(obj, 'foo')
    //  {
    //    value: 123,                   该属性的值(仅针对数据属性描述符有效)
    //    writable: true,               当且仅当属性的值可以被改变时为true。(仅针对数据属性描述有效)
    //    enumerable: true,             当且仅当指定对象的属性可以被枚举出时，为 true。
    //    configurable: true            当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为true。    
    //  }
</script>

五 属性的遍历
ES6 一共有 5 种方法可以遍历对象的属性。

（1）for...in

for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

（2）Object.keys(obj)

Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

（3）Object.getOwnPropertyNames(obj)

Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

（4）Object.getOwnPropertySymbols(obj)

Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

（5）Reflect.ownKeys(obj)

Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

首先遍历所有数值键，按照数值升序排列。
其次遍历所有字符串键，按照加入时间升序排列。
最后遍历所有 Symbol 键，按照加入时间升序排列。
Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。


六 解构赋值
七  扩展运算符

