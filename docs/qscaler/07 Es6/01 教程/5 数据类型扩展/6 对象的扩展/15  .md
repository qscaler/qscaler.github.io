对象的解构赋值＆函数参数的默认值
https://www.cnblogs.com/surfer/p/10195153.html

https://segmentfault.com/a/1190000016746873

### 一、字面量语法扩展
```js

// 在 ES6 模式下使用字面量创建对象更加简洁，对于对象属性来说，属性初始值可以简写，并可以使用可计算的属性名称。对象方法的定义消除了冒号和 function 关键字，示例如下：
// Demo1
var value = "name", age = 18;
var person = {
    age, // age: age
    ['my' + value]: 'Jenny',  // myname
    sayName () {  // sayName: function()
        console.log(this.myname)
    }
}
console.log(person.age) // 18
console.log(person.myname) // Jenny
person.sayName(); // Jenny


// 针对重复定义的对象字面量属性，ES5严格模式下会进行重复属性检查从而抛出错误，而ES6移除了这个机制，无论严格模式还是非严格模式，同名属性都会取最后一个值。
// demo2
var person = {
  ['my' + value]: 'Jenny',
  myname: 'Tom',
  myname: 'Lee',
}
console.log(person.myname) // Lee
```
### 二、新增方法
1.  Object.is( )
    ```js
    // ES6 引入Object.is()方法来弥补全等运算符的不准确计算。
    // 全等运算符在比较时不会触发强制转换类型，Object.is()运行结果也类似，但对于 +0 和 -0（在 JS 引擎中为两个不同实体）以及特殊值NaN的比较结果不同，示例来看：

    // demo3
    console.log(5 == '5') // true
    console.log(5 === '5') // false
    console.log(Object.is(5, '5')) // false

    console.log(+0 == -0) // true
    console.log(+0 === -0) // true
    console.log(Object.is(+0, -0)) // false

    console.log(NaN == NaN) // false
    console.log(NaN === NaN) // false
    console.log(Object.is(NaN, NaN)) // true
    //总结来说，Object.is()对所有值进行了更严格等价判断。当然，是否使用Object.is()代替全等操作符（===）取决于这些特殊情况是否影响代码。
    ```
2. Object.assign( )


