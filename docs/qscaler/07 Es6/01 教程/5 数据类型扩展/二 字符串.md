/*
 * @Project: 
 * @Remark: 
 * @Author: 屈晓攀
 * @Date: 2020-01-02 09:22:06
 * @LastEditors: 屈晓攀
 * @LastEditTime: 2020-05-02 13:58:01
 * @FilePath: \21 告警主题展示d:\c_person\桌面\二.字符串.js
 */
二  String

```js
    1 对象属性

        constructor	            对创建该对象的函数的引用
        length	                字符串的长度
        prototype	            允许您向对象添加属性和方法

    2 对象方法

        // 分割转化为数组
        split(",")	把字符串分割为字符串数组。
        // 提取部分字符串
        slice(start, end)	提取字符串的片断，并在新的字符串中返回被提取的部分。
        substring(start, end)	提取字符串中两个指定的索引号之间的字符。
        substr(start, length)	从起始索引号提取字符串中指定数目的字符。
            
        // 连接
        concat()	连接字符串。
        // 正则
        match()	找到一个或多个正则表达式的匹配。
        replace()	替换与正则表达式匹配的子串。
        search()	检索与正则表达式相匹配的值。
        // 大小写
        toLocaleLowerCase()	把字符串转换为小写。
        toLocaleUpperCase()	把字符串转换为大写。
        toLowerCase()	把字符串转换为小写。
        toUpperCase()	把字符串转换为大写。
        
        toString()	返回字符串。
        indexOf()	检索字符串。

        ES6
        includes() ：返回布尔值，表示是否找到了参数字符串。
        startsWith() ：返回布尔值，表示参数字符串是否在原字符串的头部。
        endsWith() ：返回布尔值，表示参数字符串是否在原字符串的尾部。
        
        trim()  消除字符串两端空格
        // anchor()	创建 HTML 锚。
        // big()	用大号字体显示字符串。
        // blink()	显示闪动字符串。
        // bold()	使用粗体显示字符串。
        // charAt()	返回在指定位置的字符。
        // charCodeAt()	返回在指定的位置的字符的 Unicode 编码。
        // fixed()	以打字机文本显示字符串。
        // fontcolor()	使用指定的颜色来显示字符串。
        // fontsize()	使用指定的尺寸来显示字符串。
        // fromCharCode()	从字符编码创建一个字符串。
        // italics()	使用斜体显示字符串。
        // lastIndexOf()	从后向前搜索字符串。
        // link()	将字符串显示为链接。
        // localeCompare()	用本地特定的顺序来比较两个字符串。
        // small()	使用小字号来显示字符串。
        // strike()	使用删除线来显示字符串。
        // sub()	把字符串显示为下标。
        // sup()	把字符串显示为上标。
        // toSource()	代表对象的源代码。
        // valueOf()	返回某个字符串对象的原始值。



情景模式 - 参数为正数
var string = 'hello world';
console.log(string.slice(3));  //lo world
console.log(string.substring(3));  //lo world
console.log(string.substr(3));  //lo world
console.log(string.slice(3, 7));  //lo w
console.log(string.substring(3, 7)); //lo w
console.log(string.substr(3, 7)); //lo worl

情景模式 - 参数为负数
slice() 会将所有的负数于字符串的长度相加
substr() 会将第一个负参数与字符串长度相加，第二个负参数转化为 0
substring() 将所有的负参数转化为 0

var string = 'hello world';  // length = 11
console.log(string.slice(-3));  // rld    slice(8)
console.log(string.substring(-3));  //hello world  substring(0)
console.log(string.substr(-3));  // rld  substr(8)
console.log(string.slice(3, -4));  //lo w slice(3, 7)
console.log(string.substring(3, -4)); //hel   substring(3, 0)
console.log(string.substr(3, -4)); //  ''   substring(3, 0)



let  变量  for循环  可以被修改 不能重复定义

const  常量  不能被修改  如果定义对象，  属性值可以被修改。


----------------------------------------------------------



var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
const用来定义常量，使用时必须初始化(即必须赋值) ，只能在块作用域里访问，而且不能修改。

const定义的对象属性是否可以改变
这是今天面试的时候碰到的一个问题，上面说到 const 是不能修改的，于是很痛快的说不能，但是回来实际测试后发现错了，在此记录一下。

const person = {
    name: 'jiuke',
    sex: '男'
}

person.name = 'test'

console.log(person.name)
运行上述代码，发现person对象的name属性确实被修改了，这是怎么回事呢？

因为对象是引用类型的，person中保存的仅是对象的指针，这就意味着，const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。

然后我们试着修改一下指针，让person指向一个新对象，果然报错

const person = {
    name: 'jiuke',
    sex: '男'
}

person = {
    name: 'test',
    sex: '男'
}

const一旦定义就不可改变

大部分情况下const的出场率比let高很多，所以一般建议默认使用const，除非一定要改变变量的值，再使用let。

const ：

    如果定义了一个基本数据类型，比如number，string 。。。 这样的话是常量，绝对不可改变。

    如果用const去定义一个Object或者Array，只能说Object或者Array本身是常量，但是还是可以他们添加删除或修改属性或者元素的。。。

    建议：
    为了让自己的代码可读性更好，建议定义完之后不再对其进行调整就用const，反之用let，var的话尽量少用或不用






【02】一定要关注箭头函数的 this 问题。
01、箭头函数不绑定this，除了不绑定this之外，还不会绑定arguments、super或new.target。

02、箭头函数体内的 this，继承的是外层代码块的 this。

03、如果对象的方法是箭头函数，那么箭头函数中的this是window，因为对象中不存在this，只能往上找，就找到了全局的 this，指向的是 window。即使这个对象在某一个函数内，也是如此。

相同的规则也适用于在 prototype 对象上定义方法。

所以，不用用箭头函数声明对象的方法。


let o = {
    // 不要这么做。
    notThis: () => {
        console.log(this) // Window
        this.objectThis() // Uncaught TypeError: this.objectThis is not a function
    },
    // 可以这么写
    objectThis: function () {
        console.log(this) // o
    }
  // 简化版
  objectThis2() {
        console.log(this) // o
    }
}


作者：吃码小妖
链接：https://www.jianshu.com/p/772d2509fed1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



04、不能使用箭头函数来创建事件监听器，因为 this 不再绑定到附加到事件监听器的元素。

可以使用 event.currentTarget 获得正确的 this 上下文。

button.addEventListener('click', function () {
    console.log(this) // button
})

button.addEventListener('click', e => {
    console.log(this) // Window
    console.log(event.currentTarget) // button
})

05、适用于定时器，定时器中的箭头函数中的this，继承外层代码块的this。

let o = {
    // Old way
    oldDoSthAfterThree: function () {
        let that = this
        setTimeout(function () {
            console.log(this) // Window
            console.log(that) // o
        })
    },
    // Arrow function way
    doSthAfterThree: function () {
        setTimeout(() => {
            console.log(this) // o
        }, 3000)
    }
}

06、箭头函数没有自己的 this，所以不能用 call() 、apply() 、bind() 这些方法去改变 this 的指向。

作者：吃码小妖
链接：https://www.jianshu.com/p/772d2509fed1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

10】不要在全局作用域定义箭头函数
因为在函数内部操作this会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将this控制在可见的范围内；

【11】一些常见例子：
例子：

// click.js
const btn = document.querySelector('button');

btn.addEventListener('click', (event) => {
    console.log('clicked');
});

例子：

// map.js
let numbers = [1, 2, 3, 4];
let multipliedBy2 = numbers.map((number) => {
    return number * 2;
});

console.log(multipliedBy2); // [2, 4, 6, 8]

例子：

const numbers = [1, 2, 3, 4];
const multipliedBy2 = numbers.map((n) => n * 2);

// 或者不需要为参数加上括号
const multipliedBy2WithShorterCallback = numbers.map(n => n * 2);

例子：

const todos = (state = [], action) => {
    switch (action.type) {
        case ADD_TODO:
            return [..state, action.text];
        default:
            return state;
    }
}

例子：

const multiply = (x) => {
    return (y) => {
        return x * y;
    }
};

const multiplyBy3 = multiply(3);
multiplyBy3(2); // 6
multiplyBy3(3); // 9
例子：

const multiply = (x) => (y) => x * y;

const multiplyBy3 = multiply(3);
multiplyBy3(2); // 6
multiplyBy3(3); // 9

下面是箭头函数的使用模式:

//  一个参数对应一个表达式
param => expression;// 例如 x => x+2;

// 多个参数对应一个表达式
(param[, param]) => expression; //例如 (x,y) => (x + y);

// 一个参数对应多个表示式
param => { statements; } //例如 x = > { x++; return x;};

//  多个参数对应多个表达式
([param] [, param]) => { statements } // 例如 (x,y) => { x++;y++;return x*y;};

//表达式里没有参数
() => expression; //例如var flag = (() => 2)(); flag等于2

() => { statements; } //例如 var flag = (() => {return 1;})(); flag就等于1

//传入一个表达式，返回一个对象
([param]) => ({ key: value });
//例如  var fuc = (x) => ({key:x})
var object = fuc(1);
alert(object);//{key:1}

作者：吃码小妖
链接：https://www.jianshu.com/p/772d2509fed1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。