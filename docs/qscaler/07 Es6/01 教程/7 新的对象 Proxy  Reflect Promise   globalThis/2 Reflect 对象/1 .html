<!--
 * @Author              : qxp
 * @Date                : 2021-03-22 17:30:19
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-10-19 12:09:19
 * @FilePath            : \new\6 Es6\7 新的对象 Proxy  Reflect Promise   globalThis\2 Reflect 对象\1 .html
-->

将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上,修改某些Object方法时，可以用Reflect对象的方法返回结果。

所以 Proxy 对象的方法可以通过调用 Reflect 对象的方法获取默认行为，然后进行额外操作。



Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。

（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，
某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。

（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，
会抛出一个错误，而Reflect.defineProperty(obj,name, desc)则会返回false。

<script>
    // 老写法
    // try {
    //     Object.defineProperty(target, property, attributes);
    //     // success
    // } catch (e) {
    //     // failure
    // }

    // // 新写法
    // if (Reflect.defineProperty(target, property, attributes)) {
    //     // success
    // } else {
    //     // failure
    // }

    let obj = {
        a: 200
    }

    var loggedObj = new Proxy(obj, {
        get(target, name) {
            console.log('get', target, name);
            return Reflect.get(target, name);
        },
        deleteProperty(target, name) {
            console.log('delete ' + name);
            return Reflect.deleteProperty(target, name);
        },
        has(target, name) {
            console.log('has' + name);
            return Reflect.has(target, name);
        }
    });

    // 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。

    // 有了Reflect对象以后，很多操作会更易读。

    // 老写法
    Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1

    // 新写法
    Reflect.apply(Math.floor, undefined, [1.75]) // 1
</script>

https://es6.ruanyifeng.com/#docs/reflect
Reflect对象一共有 13 个静态方法。

Reflect.apply(target, thisArg, args)
Reflect.construct(target, args)
Reflect.get(target, name, receiver)
Reflect.set(target, name, value, receiver)
Reflect.defineProperty(target, name, desc)
Reflect.deleteProperty(target, name)
Reflect.has(target, name)
Reflect.ownKeys(target)
Reflect.isExtensible(target)
Reflect.preventExtensions(target)
Reflect.getOwnPropertyDescriptor(target, name)
Reflect.getPrototypeOf(target)
Reflect.setPrototypeOf(target, prototype)
上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。