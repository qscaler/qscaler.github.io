<!--
 * @Author              : qxp
 * @Date                : 2021-03-22 17:32:37
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-10-24 15:58:58
 * @FilePath            : \new\6 Es6\7 新的对象 Proxy  Reflect Promise   globalThis\3 Promise 对象\1 基本用法.html
-->
Promise 的含义
基本用法
Promise.prototype.then()
Promise.prototype.catch()
Promise.prototype.finally()
Promise.all()
Promise.race()
Promise.allSettled()
Promise.any()
Promise.resolve()
Promise.reject()
应用
Promise.try()

<!-- 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，
    避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。
    ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。

-->

<script>
    // 下面代码创造了一个Promise实例。
    const promise = new Promise(function (resolve, reject) {
        // ... some code
        if (/* 异步操作成功 */) {
            resolve(value);
        } else {
            reject(error);
        }
    });
    // Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
    // resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），
    // 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（
    // 即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
    // Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
    
    // bad
    promise.then(function (value) {
        // success
    }, function (error) {
        // failure
    });
    // good
    promise.then(function (data) { //cb
        // success
    }).catch(function (err) {
        // error
    });
</script>

Promise构造函数接受一个函数做参数，该函数有resolve方法和reject方法两个参数，
若异步操作成功则用resolve方法将Promise对象的状态从pending变为resolved即“进行中”变为“成功”，
若异步操作失败则用reject方法将状态从pending变为rejected即“进行中”变为“失败”。Promise实例生成后，
可以用then方法分别指定resolve状态和rejected状态的回调函数。then方法可以接受两个回调作为入参，
第一个是promise对象的状态变为resolved的时候调用的回调，第二个是promise对象的状态变为rejected时调用的回调（第二个可选）。
<script>
    let promise = new Promise(function (resolve, reject) {
        console.log('Promise')
        resolve()
    })
    promise.then(function () {
        console.log('resolved')
    })
    console.log('Hi')
    //先打印Promise
    //再打印Hi
    //最后打印resolved（promise.then里面的属于micro task）
</script>

<script>
    const p1 = new Promise(function (resolve, reject) {
        setTimeout(() => reject(new Error('fail')), 3000)
    })

    const p2 = new Promise(function (resolve, reject) {
        setTimeout(() => resolve(p1), 1000)
    })

    p2.then(result => console.log(result)).catch(error => console.log(error))
    // Error: fail
    // 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。
    // 由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。
    // 又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。
    // 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。

    new Promise((resolve, reject) => {
        resolve(1);
        console.log(2);
    }).then(r => {
        console.log(r);
    });
    // 2
    // 1
    // 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 
    // resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。

    // 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，
    // 而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。

    new Promise((resolve, reject) => {
        return resolve(1);
        // 后面的语句不会执行
        console.log(2);
    })
</script>

<script>
    Promise
        .resolve(1)
        .then(2)
        .then(Promise.resolve(3))
        .then(console.log)
        // 解析

        // Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，
        // 则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。
        
        // then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null) ，
        // 这就会导致前一个Promise的结果会传递下面。
        // 答案 1
</script>