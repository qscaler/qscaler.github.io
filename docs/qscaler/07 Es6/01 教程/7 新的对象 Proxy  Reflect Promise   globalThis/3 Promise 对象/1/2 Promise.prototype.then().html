<!--
 * @Author              : qxp
 * @Date                : 2021-03-22 17:32:52
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-10-12 10:31:54
 * @FilePath            : \new\6 Es6\7 新的对象 Proxy  Reflect Promise\3 Promise 对象\2 Promise.prototype.then().html
-->
Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise
实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。

<script>
    // then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。

    getJSON("/posts.json").then(function (json) {
        return json.post;
    }).then(function (post) {
        // ...
    });
    // 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。
</script>


<script>

    // 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，
    // 有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。

    getJSON("/post/1.json").then(function (post) {
        return getJSON(post.commentURL);
    }).then(function funcA(comments) {
        console.log("resolved: ", comments);
    }, function funcB(err) {
        console.log("rejected: ", err);
    });
    // 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。
    // 这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，
    // 就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。

    // 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。
    // 如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。当然，一般then方法的第二个函数参数省略，而用catch函数统一捕获error。

    // 如果采用箭头函数，上面的代码可以写得更简洁。简洁也就意味着不好理解。。。

    getJSON("/post/1.json").then(
        post => getJSON(post.commentURL)
    ).then(
        comments => console.log("resolved: ", comments),
        err => console.log("rejected: ", err)
    );
</script>

<script>
    Promise.resolve(1)
        .then(2)                    //解释为then(null) ，这就会导致前一个Promise的结果会传递下面
        .then(Promise.resolve(3))
        .then(console.log)
        // 解析
        // Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，
        // 则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。

        // then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null) ，这就会导致前一个Promise的结果会传递下面。

        // 答案 1
</script>


<script>
    Promise.resolve()
        .then(() => {
            return new Error("error!!!");
        })
        .then((res) => {
            console.log("then: ", res);
        })
        .catch((err) => {
            console.log("catch: ", err);
        });
    // 运行结果
    // then: Error: error!!! at < anonymous >
</script>
解析： .then 或者 .catch 中 return 一个 error
对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种： return
Promise.reject(new Error(‘error!!!’)) throw new Error(‘error!!!’)
因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new
Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。

<script>
    const promise = Promise.resolve().then(() => {
        return promise;
    });
    promise.catch(console.error);
    // 运行结果
    // TypeError: Chaining cycle detected for promise # < Promise >
    // 解析：.then 或.catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：

    process.nextTick(function tick() {
        console.log("tick");
        process.nextTick(tick);
    });
</script>

<script>
    Promise
        .resolve()
        .then(
            function success(res) {
                throw new Error("error");
            },
            function fail1(e) {
                console.error("fail1: ", e);
            }
        )
        .catch(function fail2(e) {
            console.error("fail2: ", e);
        });
    // 运行结果
    // fail2: Error: error  at success(<anonymous>)
    // 解析：
    // .then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。
    // .catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。
</script>