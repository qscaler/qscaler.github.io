<!--
 * @Author              : qxp
 * @Date                : 2021-03-24 17:13:37
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-10-12 10:52:26
 * @FilePath            : \new\6 Es6\7 新的对象 Proxy  Reflect Promise\3 Promise 对象\20 Promise面试题.html
-->
题目一
<script>
    const promise = new Promise((resolve, reject) => {
        //Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。
        console.log(1);
        resolve();
        console.log(2);
    });

    promise.then(() => {
        console.log(3);
    });

    console.log(4);
</script>
解析
首先Promise新建后立即执行，所以会先输出1,2，而Promise.then()内部的代码在当次事件循环的结尾立即执行，所以会先输出4，最后输出3.
答案：1 2 4 3 题目二

<script>
    const promise = new Promise((resolve, reject) => {
        resolve("success1");
        reject("error");
        resolve("success2");
    });

    promise
        .then((res) => {
            console.log("then:", res);    //then: success1
        })
        .catch((err) => {
            console.log("catch:", err);
        });

</script>
<script>
    const promise1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("success");
        }, 1000);
    });
    const promise2 = promise1.then(() => {
        throw new Error("error!!!");
    });

    console.log("promise1", promise1);
    console.log("promise2", promise2);

    setTimeout(() => {
        console.log("promise1", promise1);
        console.log("promise2", promise2);
    }, 2000);

    // 运行结果
    // promise1 Promise {<pending>}
    // promise2 Promise {<pending>}

    // Uncaught (in promise) Error: error!!! at <anonymous>

    // promise1 Promise {<resolved>: "success"}
    // promise2 Promise {<rejected>: Error: error!!!at <anonymous>}
    // promise 有 3 种状态：pending、fulfilled 或 rejected。状态改变只能是 pending -> fulfilled 或者 pending -> rejected，
    // 状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。
</script>
解析
resolve函数Promise对象的状态从“未完成”变为“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
reject函数将Promise对象的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
而一旦状态改变，就不会有再变。所以代码中的reject('error');不会有作用。Promise只能resolve一次，剩下的调用都会被忽略。
所以第二次resolve('success');也不会有作用。 答案：then：success1 题目三
<script>
    Promise.resolve(1)
        .then((res) => {
            console.log(res);
            return 2;
        })
        .catch((err) => {
            return 3;
        })
        .then((res) => {
            console.log(res);
        });
    // 运行结果
    // 1
    // 2
</script>
解析： promise 可以链式调用。提起链式调用我们通常会想到通过 return this
实现，不过 Promise 并不是这样实现的。 promise 每次调用 .then 或者 .catch都会返回一个新的promise，从而实现了链式调用。
<script>
    Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log);
</script>

解析 Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，
则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。(原始值1会往下传（then获取到）)
then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。
.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透 答案 1
<script>
    const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("once");
            resolve("success");
        }, 1000);
    });

    const start = Date.now();
    promise.then((res) => {
        console.log(res, Date.now() - start);
    });
    promise.then((res) => {
        console.log(res, Date.now() - start);
    });
    // 运行结果
    // once
    // success 1005
    // success 1007

    // promise 的.then 或者.catch 可以被调用多次，但这里 Promise 构造函数只执行一次。
    // 或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用.then 或者.catch 都会直接拿到该值。
</script>

题目四
红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：
<script>
    function red() {
        console.log("red");
    }
    function green() {
        console.log("green");
    }
    function yellow() {
        console.log("yellow");
    }
</script>
解析 红灯3秒亮一次，绿灯1秒亮一次
，黄灯2秒亮一次，意思就是3秒执行一次red函数，2秒执行一次green函数，1秒执行一次yellow函数，
不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以利用递归来实现。
答案
<script>
    function red() {
        console.log("red");
    }
    function green() {
        console.log("green");
    }
    function yellow() {
        console.log("yellow");
    }

    var light = function (timmer, cb) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                cb();
                resolve();
            }, timmer);
        });
    };
    var step = function () {
        Promise.resolve()
            .then(function () {
                return light(3000, red);
            })
            .then(function () {
                return light(2000, green);
            })
            .then(function () {
                return light(1000, yellow);
            })
            .then(function () {
                step();
            });
    };
    step();
</script>

题目五
实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。
<script>
    const timeout = (ms) =>
        new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve();
            }, ms);
        });

    const ajax1 = () =>
        timeout(2000).then(() => {
            console.log("1");
            return 1;
        });

    const ajax2 = () =>
        timeout(1000).then(() => {
            console.log("2");
            return 2;
        });

    const ajax3 = () =>
        timeout(2000).then(() => {
            console.log("3");
            return 3;
        });

    const mergePromise = (ajaxArray) => {
        // 在这里实现你的代码
        var data = [];

        // Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。
        var sequence = Promise.resolve();

        ajaxArray.forEach(function (item) {
            // 第一次的 then 方法用来执行数组中的每个函数，
            // 第二次的 then 方法接受数组中的函数执行后返回的结果，
            // 并把结果添加到 data 中，然后把 data 返回。
            sequence = sequence.then(item).then(function (res) {
                data.push(res);
                return data;
            });
        });

        // 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，
        // 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。
        return sequence;
    };

    mergePromise([ajax1, ajax2, ajax3]).then((data) => {
        console.log("done");
        console.log(data); // data 为 [1, 2, 3]
    });
    // 要求分别输出
    // 1
    // 2
    // 3
    // done
    // [1, 2, 3]
</script>

解析
首先ajax1，ajax2，ajax3都是函数，只是这些函数执行后会返回一个Promise，按照题目要求只要顺序执行这三个函数就好了，
然后把结果放到data中，但是这些函数都是异步操作，想要按顺序执行输出1,2,3并非那么容易，举例

<script>
    function A() {
        setTimeout(function () {
            console.log("a");
        }, 3000);
    }

    function B() {
        setTimeout(function () {
            console.log("b");
        }, 1000);
    }
    A();
    B();
    // b
    // a
</script>

例子中按照顺序执行A，B但是输出的结果却是b，a。因为对于异步函数来说，并不会按顺序执行完一个，再执行后一个。
这道题主要考察用Promise控制异步流程，让这些涵涵素，一个执行完，再执行下一个。
答案

<script>
    // 保存数组中的函数执行后的结果
    var data = [];

    // Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。
    var sequence = Promise.resolve();

    ajaxArray.forEach(function (item) {
        // 第一次的 then 方法用来执行数组中的每个函数，
        // 第二次的 then 方法接受数组中的函数执行后返回的结果，
        // 并把结果添加到 data 中，然后把 data 返回。
        sequence = sequence.then(item).then(function (res) {
            data.push(res);
            return data;
        });
    });

    // 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，
    // 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。
    return sequence;
</script>

题目六 以下代码最后输出什么
<script>
    const first = () =>
        new Promise((resolve, reject) => {
            console.log(3);
            let p = new Promise((resolve, reject) => {
                console.log(7);
                setTimeout(() => {
                    console.log(5);
                    resolve(6); //resolve(6)不会生效，因为p的Promise状态一旦改变就不会再变化了。
                }, 0);
                resolve(1);
            });
            resolve(2);
            p.then((arg) => {
                //p的then，暂且命名为then1  ,输出 1
                console.log(arg);
            });
        });

    first().then((arg) => {
        //且first也有then，命名为then2  ,输出 2
        console.log(arg);
    });
    console.log(4);
    // 3 7 4 1 2  5
</script>
解析 这道题主要理解js执行机制 第一轮事件循环 先执行宏任务，主script， first()会导致 new
Promise立即执行，输出 3， 执行p这个new Promise操作，输出 7，
发现setTimeout，将回调函数放入下一轮任务队列（Event
Quene），p的then，暂且命名为then1，放入微任务队列，且first也有then，命名为then2，放入微任务队列。执行console.log(4),输出
4，宏任务执行结束。 再执行微任务，执行then1,输出 1， 执行then2,输出 2.
第一轮事件循环结束，开始执行第二轮 setTimeout。 答案 3 7 4 1 2 5 



题目七
有8个图片资源的url，已经存储在数组urls中（即urls=['http://example.com/1.jpg',...,'http:''example.com/8.jpg']），而且已经有一个函数function
loading，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。
但有一个要求，任何时刻同时下载的链接数量不可以超过3个。
请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。
<script>
    var urls = [
        "https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg",
        "https://www.kkkk1000.com/images/getImgData/gray.gif",
        "https://www.kkkk1000.com/images/getImgData/Particle.gif",
        "https://www.kkkk1000.com/images/getImgData/arithmetic.png",
        "https://www.kkkk1000.com/images/getImgData/arithmetic2.gif",
        "https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg",
        "https://www.kkkk1000.com/images/getImgData/arithmetic.gif",
        "https://www.kkkk1000.com/images/wxQrCode2.png",
    ];
    function loadImg(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = function () {
                console.log("一张图片加载完成");
                resolve();
            };
            img.onerror = reject;
            img.src = url;
        });
    }
</script>
解析
题目的意思是需要先并发请求3张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在3个，直到需要加载的图片都全部发起请求。
用Promise来实现就是，先并发请求3个图片资源，这样可以得到3个Promise，组成一个数组promises，
然后不断调用Promise.race来返回最快改变状态的Promise，然后从数组promises中删掉这个Promise对象，再加入一个新的Promise，
直到全部的url被取完，最后再使用Promise.all来处理一遍数组promises中没有改变状态的Promise
答案

<script>
    var urls = [
        "https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg",
        "https://www.kkkk1000.com/images/getImgData/gray.gif",
        "https://www.kkkk1000.com/images/getImgData/Particle.gif",
        "https://www.kkkk1000.com/images/getImgData/arithmetic.png",
        "https://www.kkkk1000.com/images/getImgData/arithmetic2.gif",
        "https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg",
        "https://www.kkkk1000.com/images/getImgData/arithmetic.gif",
        "https://www.kkkk1000.com/images/wxQrCode2.png",
    ];
    function loadImg(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = function () {
                console.log("一张图片加载完成");
                resolve();
            };
            img.onerror = reject;
            img.src = url;
        });
    }

    function limitLoad(urls, handler, limit) {
        // 对数组做一个拷贝
        const sequence = [].concat(urls);
        let promises = [];

        //并发请求到最大数
        promises = sequence.splice(0, limit).map((url, index) => {
            // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标
            return handler(url).then(() => {
                return index;
            });
        });

        // 利用数组的 reduce 方法来以队列的形式执行
        return sequence
            .reduce((last, url, currentIndex) => {
                return last
                    .then(() => {
                        // 返回最快改变状态的 Promise
                        return Promise.race(promises); //那个率先改变的 Promise 实例的返回值，就传递给p的回调函数
                    })
                    .catch((err) => {
                        // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误
                        // 更重要的是防止中断整个链式调用
                        console.error(err);
                    })
                    .then((res) => {
                        // 用新的 Promise 替换掉最快改变状态的 Promise
                        promises[res] = handler(sequence[currentIndex]).then(
                            () => {
                                return res;
                            }
                        );
                    });
            }, Promise.resolve())
            .then(() => {
                return Promise.all(promises);
            });
    }
    limitLoad(urls, loadImg, 3);

    /*
        因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用
        
        limitLoad(urls, loadImg, 3).then(() => {
            console.log('所有图片加载完成');
        }).catch(err => {
            console.error(err);
        })
    */
</script>

题目七 封装一个异步加载图片的方法

<script>
    function loadImageAsync(url) {
        return new Promise(function (resolve, reject) {
            var image = new Image();
            image.onload = function () {
                resolve(image);
            };
            image.onerror = function () {
                reject(new Error("Could not load image at" + url));
            };
            image.src = url;
        });
    }
</script>

<script>
    Promise.resolve()
        .then(() => {
            return new Error("error!!!");
        })
        .then((res) => {
            console.log("then: ", res);
        })
        .catch((err) => {
            console.log("catch: ", err);
        });
    // 运行结果
    // then: Error: error!!! at < anonymous >
</script>
解析： .then 或者 .catch 中 return 一个 error
对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种： return
Promise.reject(new Error(‘error!!!’)) throw new Error(‘error!!!’)
因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new
Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。

<script>
    const promise = Promise.resolve().then(() => {
        return promise;
    });
    promise.catch(console.error);
    // 运行结果
    // TypeError: Chaining cycle detected for promise # < Promise >
    // 解析：.then 或.catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：

    process.nextTick(function tick() {
        console.log("tick");
        process.nextTick(tick);
    });
</script>

<script>
    Promise
        .resolve()
        .then(
            function success(res) {
                throw new Error("error");
            },
            function fail1(e) {
                console.error("fail1: ", e);
            }
        )
        .catch(function fail2(e) {
            console.error("fail2: ", e);
        });
    // 运行结果
    // fail2: Error: error  at success(<anonymous>)
    // 解析：
    // .then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。
    // .catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。
</script>
