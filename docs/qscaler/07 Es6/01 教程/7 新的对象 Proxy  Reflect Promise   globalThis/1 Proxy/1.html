<!--
 * @Author              : qxp
 * @Date                : 2021-03-22 17:05:33
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-10-19 12:06:51
 * @FilePath            : \new\6 Es6\7 新的对象 Proxy  Reflect Promise   globalThis\1 Proxy\1.html
-->
1 概述
Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，
可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。


4324
get   set   has  apply 
defineProperty   deleteProperty   getOwnPropertyDescriptor
getPrototypeOf   setPrototypeOf  
ownKeys  construct isExtensible  preventExtensions



<script>
    var proxy = new Proxy({}, {
        get: function (target, propKey) {
            return 35;
        }
    });
    proxy.time // 35
    proxy.name // 35
    proxy.title // 35

    // ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。
    var proxy = new Proxy(target, handler);
    // Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，
    // handler参数也是一个对象，用来定制拦截行为。

</script>

   
<script>
    // 下面是 Proxy 支持的拦截操作一览，一共 13 种。  get set    has  apply defineProperty  deleteProperty  getPrototypeOf setPrototypeOf  

    //：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
    get(target, propKey, receiver)   
    
    
    //：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
    set(target, propKey, value, receiver)               

    // 拦截propKey in proxy的操作，返回一个布尔值。
    has(target, propKey)

    //：拦截delete proxy[propKey]的操作，返回一个布尔值。
    deleteProperty(target, propKey)                   

    //：拦截Object.getOwnPropertyNames(proxy) 、Object.getOwnPropertySymbols(proxy) 、Object.keys(proxy) 、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
    ownKeys(target)                        

    //：拦截Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。
    getOwnPropertyDescriptor(target, propKey)           
    
    //：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs) ，返回一个布尔值。
    defineProperty(target, propKey, propDesc)           

    //：拦截Object.preventExtensions(proxy) ，返回一个布尔值。
    preventExtensions(target)                           

    //：拦截Object.getPrototypeOf(proxy) ，返回一个对象。
    getPrototypeOf(target)                               

    //：拦截Object.isExtensible(proxy) ，返回一个布尔值。
    isExtensible(target)                               

    //：拦截Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
    setPrototypeOf(target, proto)                       

    // ：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args) 、proxy.call(object, ...args) 、proxy.apply(...) 。
    apply(target, object, args)                         
    
    //：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args) 。
    construct(target, args)                             
</script>

1 get
get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。
get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。
<script>
    var person = {
        name: "张三"
    };

    var proxy = new Proxy(person, {
        get: function (target, propKey) {
            if (propKey in target) {
                return target[propKey];
            } else {
                throw new ReferenceError("Prop name \"" + propKey + "\" does not exist.");
            }
        }
    });

    proxy.name // "张三"
    proxy.age // 抛出一个错误
</script>
2 set
set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。
假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。
<script>
    let validator = {
        set: function (obj, prop, value) {
            if (prop === 'age') {
                if (!Number.isInteger(value)) {
                    throw new TypeError('The age is not an integer');
                }
                if (value > 200) {
                    throw new RangeError('The age seems invalid');
                }
            }
            // 对于满足条件的 age 属性以及其他属性，直接保存
            obj[prop] = value;
        }
    };

    let person = new Proxy({}, validator);

    person.age = 100;

    person.age // 100
    person.age = 'young' // 报错
    person.age = 300 // 报错
</script>

3 apply
apply方法拦截函数的调用、call和apply操作。
apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。
<script>
    var target = function () { return 'I am the target'; };
    var handler = {
        apply: function () {
            return 'I am the proxy';
        }
    };
    var p = new Proxy(target, handler);
    p()
    // "I am the proxy"
    // 上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p() ），就会被apply方法拦截，返回一个字符串。

    {
        var twice = {
            //目标对象，目标对象的上下文对象，目标对象的参数数组
            apply: function (target, ctx, args) {
                //return console.log("target",target,"ctx",ctx,"args",args);
                return Reflect.apply(...arguments) * 2;
            }
        };
        function sum(left, right) {
            return left * right;
        };
        var proxy = new Proxy(sum, twice);
        console.log("proxy1", proxy(1, 2));
        console.log("proxy.call", proxy.call(null, 5, 6));
        console.log("proxy,apply", proxy.apply(null, [7, 8]));
        console.log("proxy,apply", Reflect.apply(proxy, null, [7, 8]));

    }
    //上面的实例执行顺序是当sum（）执行完后再执行twice中的apply()，
    //上面代码中每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截
    //另外，直接调用Reflect.apply方法，也会被拦截。



    
    var twice = {
        apply(target, ctx, args) {//能获取到改变的ctx
            if (args[0] - args[1] < 0) {
                args[1] = 0;
            }
            return target(...args);//但没有在这里修改上下文指向,所以无法生效
        }
    };
    function sum(left, right) {
        return this.demo ? this.demo : left - right;
    };
    var proxy = new Proxy(sum, twice);
    console.log(
        proxy(1, 2),
        proxy.call({ demo: 2 }, 5, 6),
        proxy.apply({ demo: 4 }, [7, 8]),
        proxy.bind({ demo: 6 }, 1, 2)()
    )// 1 5 7 1
    console.log(
        sum(1, 2),
        sum.call({ demo: 2 }, 5, 6),
        sum.apply({ demo: 4 }, [7, 8]),
        sum.bind({ demo: 6 }, 1, 2)()
    )// -1 2 4 6
</script>

4 has()
has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。

has()方法可以接受两个参数，分别是目标对象、需查询的属性名。
值得注意的是，has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。

另外，虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效
<script>
    // 下面的例子使用has()方法隐藏某些属性，不被in运算符发现。
    var handler = {
        has(target, key) {
            if (key[0] === '_') {
                return false;
            }
            return key in target;
        }
    };
    var target = { _prop: 'foo', prop: 'foo' };
    var proxy = new Proxy(target, handler);
    '_prop' in proxy // false
</script>

5 construct()
construct()方法用于拦截new命令，下面是拦截对象的写法。 由于construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。
<script>
    const p = new Proxy(function () { }, {
        construct: function (target, args) {
            console.log('called: ' + args.join(', '));
            return { value: args[0] * 10 };
        }
    });

    (new p(1)).value
    // "called: 1"
    // 10
</script>

6 deleteProperty()
deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。

<script>
    // 上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。
    // 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。
    var handler = {
        deleteProperty(target, key) {
            invariant(key, 'delete');
            delete target[key];
            return true;
        }
    };
    function invariant(key, action) {
        if (key[0] === '_') {
            throw new Error(`Invalid attempt to ${action} private "${key}" property`);
        }
    }

    var target = { _prop: 'foo' };
    var proxy = new Proxy(target, handler);
    delete proxy._prop
    // Error: Invalid attempt to delete private "_prop" property
</script>
7 defineProperty() § ⇧
defineProperty()方法拦截了Object.defineProperty()操作
<script>
    var handler = {
        defineProperty(target, key, descriptor) {
            return false;
        }
    };
    var target = {};
    var proxy = new Proxy(target, handler);
    proxy.foo = 'bar' // 不会生效
    // 上面代码中，defineProperty()方法内部没有任何操作，只返回false，导致添加新属性总是无效。注意，这里的false只是用来提示操作失败，本身并不能阻止添加新属性。
    // 注意，如果目标对象不可扩展（non - extensible），则defineProperty()不能增加目标对象上不存在的属性，否则会报错。
    // 另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty()方法不得改变这两个设置。
</script>
8 getOwnPropertyDescriptor()
getOwnPropertyDescriptor()方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。

<script>
    var handler = {
        getOwnPropertyDescriptor(target, key) {
            if (key[0] === '_') {
                return;
            }
            return Object.getOwnPropertyDescriptor(target, key);
        }
    };
    var target = { _foo: 'bar', baz: 'tar' };
    var proxy = new Proxy(target, handler);
    Object.getOwnPropertyDescriptor(proxy, 'wat')
    // undefined
    Object.getOwnPropertyDescriptor(proxy, '_foo')
    // undefined
    Object.getOwnPropertyDescriptor(proxy, 'baz')
    // { value: 'tar', writable: true, enumerable: true, configurable: true }
    // 上面代码中，handler.getOwnPropertyDescriptor()方法对于第一个字符为下划线的属性名会返回undefined。
</script>
9 getPrototypeOf()
<script>
    // getPrototypeOf()方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。
    Object.prototype.__proto__
    Object.prototype.isPrototypeOf()
    Object.getPrototypeOf()
    Reflect.getPrototypeOf()
        instanceof

    // 下面是一个例子。
    var proto = {};
    var p = new Proxy({}, {
        getPrototypeOf(target) {
            return proto;
        }
    });
    Object.getPrototypeOf(p) === proto // true
    // 上面代码中，getPrototypeOf()方法拦截Object.getPrototypeOf() ，返回proto对象。
    // 注意，getPrototypeOf()方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（non - extensible）， getPrototypeOf()方法必须返回目标对象的原型对象。
</script>
10 isExtensible()
isExtensible()方法拦截Object.isExtensible()操作。
<script>
    var p = new Proxy({}, {
        isExtensible: function (target) {
            console.log("called");
            return true;
        }
    });

    Object.isExtensible(p)
    // "called"
    // true
    // 上面代码设置了isExtensible()方法，在调用Object.isExtensible时会输出called。
    // 注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。
    // 这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。

    Object.isExtensible(proxy) === Object.isExtensible(target)
    // 下面是一个例子。

    var p = new Proxy({}, {
        isExtensible: function (target) {
            return false;
        }
    });
    Object.isExtensible(p)
    // Uncaught TypeError: 'isExtensible' on proxy: trap result does not reflect exten



    // 新对象默认是可扩展的.
    var empty = {};
    Object.isExtensible(empty); // === true

    // ...可以变的不可扩展.
    Object.preventExtensions(empty);
    Object.isExtensible(empty); // === false

    // 密封对象是不可扩展的.
    var sealed = Object.seal({});
    Object.isExtensible(sealed); // === false

    // 冻结对象也是不可扩展.
    var frozen = Object.freeze({});
    Object.isExtensible(frozen); // === false
</script>
11 ownKeys()
ownKeys()方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。
<script>

    Object.getOwnPropertyNames()
    Object.getOwnPropertySymbols()
    Object.keys()
    // for...in循环
    // 下面是拦截Object.keys()的例子。

    let target = {
        a: 1,
        b: 2,
        c: 3
    };

    let handler = {
        ownKeys(target) {
            return ['a'];
        }
    };

    let proxy = new Proxy(target, handler);

    Object.keys(proxy)
    // [ 'a' ]
    // 上面代码拦截了对于target对象的Object.keys()操作，只返回a、b、c三个属性之中的a属性。
</script>
12 preventExtensions()
preventExtensions()方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。

这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。
<script>

    var proxy = new Proxy({}, {
        preventExtensions: function (target) {
            return true;
        }
    });

    Object.preventExtensions(proxy)
    // Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible
    // 上面代码中，proxy.preventExtensions()方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。

    // 为了防止出现这个问题，通常要在proxy.preventExtensions()方法里面，调用一次Object.preventExtensions() 。

    var proxy = new Proxy({}, {
        preventExtensions: function (target) {
            console.log('called');
            Object.preventExtensions(target);
            return true;
        }
    });

    Object.preventExtensions(proxy)
    // "called"
    // Proxy {}
</script>
13 setPrototypeOf()
setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法。
<script>
    // 下面是一个例子。
    var handler = {
        setPrototypeOf(target, proto) {
            throw new Error('Changing the prototype is forbidden');
        }
    };
    var proto = {};
    var target = function () { };
    var proxy = new Proxy(target, handler);
    Object.setPrototypeOf(proxy, proto);
    // Error: Changing the prototype is forbidden
    // 上面代码中，只要修改target的原型对象，就会报错。
    // 注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non - extensible），setPrototypeOf()方法不得改变目标对象的原型。

</script>

c5962BEM
52931148