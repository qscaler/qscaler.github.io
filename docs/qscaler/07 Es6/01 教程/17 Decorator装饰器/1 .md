---
title: 1 装饰器
---

<!--
 * @Author              : qxp
 * @Date                : 2021-03-22 17:35:53
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-03-22 17:40:10
 * @FilePath            : \new\6 Es6\17 装饰器\1.html
-->


装饰器可以用来装饰整个类。

ts  教程里边有


```js
    @testable
    class MyTestableClass {
        // ...
    }

    function testable(target) {
        target.isTestable = true;
    }

    MyTestableClass.isTestable // true
    // 上面代码中，@testable就是一个装饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。

    // 基本上，装饰器的行为就是下面这样。

    @decorator
    class A { }

    // 等同于

    class A { }
    A = decorator(A) || A;
```


```js
    // 前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。

    function testable(target) {
        target.prototype.isTestable = true;
    }

    @testable
    class MyTestableClass { }

    let obj = new MyTestableClass();
    obj.isTestable // true
```

```js
    // mixins.js
        export function mixins(...list) {
            return function (target) {
                Object.assign(target.prototype, ...list)
            }
        }

        // main.js
        import { mixins } from './mixins'

        const Foo = {
            foo() { console.log('foo') }
        };

        @mixins(Foo)
        class MyClass { }

        let obj = new MyClass();
        obj.foo() // 'foo'
        // 上面代码通过装饰器mixins，把Foo对象的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。

        const Foo = {
            foo() { console.log('foo') }
        };

        class MyClass { }

        Object.assign(MyClass.prototype, Foo);

        let obj = new MyClass();
        obj.foo() // 'foo'
        // 实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。


        
        class MyReactComponent extends React.Component { }

        export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
        // 有了装饰器，就可以改写上面的代码。

        @connect(mapStateToProps, mapDispatchToProps)
        export default class MyReactComponent extends React.Component { }
        // 相对来说，后一种写法看上去更容易理解。
```