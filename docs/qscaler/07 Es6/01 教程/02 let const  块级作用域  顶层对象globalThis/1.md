## let 和 const 命令

### 一 let 命令
总结 
    1 不存在变量提升
    2 不允许重复声明
    3 存在暂时性死区
    4 只在声明的变量所在的代码块内有效
    5 在全局声明 不会被添加到 window 对象中
    6 可以不立即赋值，可以更改其值

1. 基本用法

    ```js
    //ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效
    {
        let a = 10;
        var b = 1;
    }
    a // ReferenceError: a is not defined.
    b // 1
    ```
    
    ```js
    // 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量）。   

    for (let i = 0; i < 3; i++) {
        let i = 'abc';
        console.log(i);
    }
    // abc
    // abc
    // abc
    ```
2. 不存在变量提升
    ```js
    //var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误

    // var 的情况
    console.log(foo); // 输出undefined
    var foo = 2;

    // let 的情况
    console.log(bar); // 报错ReferenceError
    let bar = 2;
    ```
3. 不允许重复声明

    ```js
    //1 let不允许在相同作用域内，重复声明同一个变量。
    // 报错
    function func() {
        let a = 10;
        var a = 1;//Uncaught SyntaxError: Identifier 'a' has already been declared
    }
    function func() {
        var a = 10;
        let a = 1;//Uncaught SyntaxError: Identifier 'a' has already been declared
    }
    // 报错
    function func() {
        let a = 10;
        let a = 1;//Uncaught SyntaxError: Identifier 'a' has already been declared
    }


    //2 因此，不能用let在函数内部重新声明参数。
    //参数作用域会带入函数体，所以参数已经声明的变量，函数体内不得用let再次声明。
    function func(arg) {
        let arg;
    }
    func() // 报错
    
    function func(arg) {
        var arg;
    }
    func() //不报错
    
    function func(arg) {
        {
            let arg;
        }
    }
    func() // 不报错
    
    ```
4. 存在暂时性死区

    ```js
    //只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

    var tmp = 123;

    if (true) {
        tmp = 'abc'; // ReferenceError
        let tmp;
    }
    //上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
    //ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
    //总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

    if (true) {
        // TDZ开始
        tmp = 'abc'; // ReferenceError
        console.log(tmp); // ReferenceError   Uncaught ReferenceError: Cannot access 'tmp' before initialization

        let tmp; // TDZ结束
        console.log(tmp); // undefined

        tmp = 123;
        console.log(tmp); // 123
    }
    上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。

    “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。

    typeof x; // ReferenceError
    let x;
    //上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。

    //作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。

    typeof undeclared_variable // "undefined"
    //上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。

    //有些“死区”比较隐蔽，不太容易发现。

    function bar(x = y, y = 2) {
        return [x, y];
    }

    bar(); // 报错
    //上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。

    function bar(x = 2, y = x) {
        return [x, y];
    }
    bar(); // [2, 2]
    //另外，下面的代码也会报错，与var的行为不同。

    // 不报错
    var x = x;

    // 报错
    let x = x;
    // ReferenceError: x is not defined
    //上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。

    //ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

    ```
    总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量

    一个作用域内 存在let const变量声明，那么只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
### 二 [块级作用域](https://es6.ruanyifeng.com/#docs/let)
1.  为什么需要块级作用域？
    **ES5 只有全局作用域和函数作用域，没有块级作用域**，这带来很多不合理的场景
    1. 第一种场景，**内层变量可能会覆盖外层变量**
        ```js
        var tmp = new Date();

        function f() {
            console.log(tmp);
            if (false) {
                var tmp = 'hello world';     //内部tmp会变量提升  为undefined
            }
        }
        
        f(); // undefined
        //上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量
        ```
    2. 第二种场景，**用来计数的循环变量泄露为全局变量**。
        ```js
        var s = 'hello';

        for (var i = 0; i < s.length; i++) {
            console.log(s[i]);
        }
        console.log(i); // 5
        //上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。
        ```
2.  ES6 的块级作用域
    ```js
    function f1() {
        let n = 5;
        if (true) {
            let n = 10;
        }
        console.log(n); // 5
    }
    //上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。

    //ES6 允许块级作用域的任意嵌套。
    {{{{
        {let insane = 'Hello World'}
        console.log(insane); // 报错
    }}}};
    //上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。

    //内层作用域可以定义外层作用域的同名变量。
    {{{{
        let insane = 'Hello World';
        {let insane = 'Hello World'}
    }}}};

    //!! 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。
    // IIFE 写法
    (function () {
        var tmp = ...;
        ...
    }());

    // 块级作用域写法
    {
        let tmp = ...;
        ...
    }
    ```
3.  块级作用域与函数声明
    ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
    **如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定**，有自己的行为方式。

    1 允许在块级作用域内声明函数。
    2 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
    3 同时，函数声明还会提升到所在的块级作用域的头部。
    注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

    根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量
    **考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句**。
    另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

### 三 const 命令
总结
    1 不存在变量提升
    2 不允许重复声明
    3 存在暂时性死区
    4 只在声明的变量所在的代码块内有效
    5 在全局声明 不会被添加到 window 对象中
    6 一旦声明必须赋值,不能使用null占位
    7 声明的是简单类型数据，不可以修改其值，声明的是复合类型数据，可以修改其属性
1. 基本用法
    1.  当 const声明一个只读的常量。一旦声明，常量的值就不能改变。
        const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
        const的作用域与let命令相同：只在声明所在的块级作用域内有效。
        const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
        const声明的常量，也与let一样不可重复声明。
    ```js
    const foo = {};

    // 为 foo 添加一个属性，可以成功
    foo.prop = 123;
    foo.prop // 123

    // 将 foo 指向另一个对象，就会报错
    foo = {}; // TypeError: "foo" is read-only

    //-----------------------------------------
    const a = [];
    a.push('Hello'); // 可执行
    a.length = 0;    // 可执行
    a = ['Dave'];    // 报错

    //如果真的想将对象冻结，应该使用Object.freeze方法。
    const foo = Object.freeze({});

    // 常规模式时，下面一行不起作用；
    // 严格模式时，该行会报错
    foo.prop = 123;
    //上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。

    //除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

    var constantize = (obj) => {
        Object.freeze(obj);
        Object.keys(obj).forEach( (key, i) => {
            if ( typeof obj[key] === 'object' ) {
                constantize( obj[key] );
            }
        });
    };
    ```
    const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
    对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
    但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，
    const只能保证这个指针是固定的（即总是指向另一个固定的地址），
    至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心

2.  ES6 声明变量的六种方法
    **ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法**
### 四 顶层对象的属性
1. 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
    ```js
    window.a = 1;
    a // 1

    a = 2;
    window.a // 2
    //上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。
    ```

    **顶层对象（window）的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一**。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象设计成是一个有实体含义的对象，也是不合适的。

    ES6 为了改变这一点，一方面规定，**为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩**。

    ```js
    var a = 1;
    // 如果在 Node 的 REPL 环境，可以写成 global.a
    // 或者采用通用方法，写成 this.a
    window.a // 1

    let b = 1;
    window.b // undefined
    //上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。
    ```
### 五 globalThis 对象
[ES6学习笔记之 this 详解 ](https://www.cnblogs.com/ly2019/p/11006188.html)
1. JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。

    1. 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
    2. 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
    3. Node 里面，顶层对象是global，但其他环境都不支持。
    4. 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this关键字，但是有局限性。

    **全局环境中，this会返回顶层对象。但是，Node.js 模块中this返回的是当前模块，ES6 模块中this返回的是undefined。**
    函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
    不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。
    ```js
    // 方法一
    (typeof window !== 'undefined'? window: (typeof process === 'object' &&typeof require === 'function' &&typeof global === 'object')? global: this);

    // 方法二
    var getGlobal = function () {
        if (typeof self !== 'undefined') { return self; }
        if (typeof window !== 'undefined') { return window; }
        if (typeof global !== 'undefined') { return global; }
        throw new Error('unable to locate global object');
    };
    ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。

    垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。
    ```
    ```js
         
            function test() {
                var a = 1;

                console.log(a);//函数未调用 输出的是undefined  函数调用输出的是1
                console.log(this);//Window
            }


            test()

        //----------------------
       
            (function () {
                var a = b = 3;
            })()
            console.log(typeof a);
            console.log(typeof b);
            console.log(2222222222);
            console.log(a);
            console.log(b);
        //----------------------

       
            function f() {
                console.log(a);
                a = 3;
            }

            var liu = 0;
            function show() {
                liu = 1;  //在定义名称的函数内 没加var的已定义全局变量liu
                jin = 2;
            } 
            show()
             console.log(liu) // 结果是 1
             console.log(jin) // 结果是 2
            // 在函数内，不加var定义的变量，会扩散到全局环境中
        //----------------------


       

            //箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。箭头函数导致 this 总是指向函数定义生效时所在的对象。
            function Timer(params) {
                this.s1=0
                this.s2=0
                setInterval(() => {
                    this.s1++
                    //  console.log(this);
                }, 1000);
                 setInterval(function(){
                    // console.log(this.s2);
                    this.s2++
                    // console.log(this);
                }, 1000);
            }

            var timter=new Timer()
            setTimeout(() => {
                console.log(timter.s1);
            }, 3100);
             setTimeout(() => {
                console.log(timter.s2);
            }, 3100);
            //上面代码中， Timer 函数内部设置了两个定时器，分别使用了箭头函数和普通函数。箭头函数的 this 绑定定义时所在的作用域（即 Timer 函数），普通函数的 this 指向运行时所在的作用域（即全局对象）。var timer = new Timer() 这条语句执行之后，再过1000毫秒，箭头函数定义生效，this总是指向函数定义生效时所在对象，即timer；对于普通函数，因为setTimeout()调用的代码运行在与所在函数完全分离的执行环境上，这会导致 this 指向 window 对象。所以3100毫秒之后，timer.s1 被更新了3次，而 timer.s2 一次都没更新。
        //----------------------
       

            //   setInterval(function () {
            //         // console.log(this.s2);
            //         // this.s2++
            //         console.log(this);
            // }, 1000);

            function aa(params) {
                console.log(this);
            }
            aa()//Window
        //----------------------

       
            function Test(params) {
                this.g=1
                function name(params) {
                    console.log(this);  //Window
                }
                name()
                console.log(this);  //Test {g: 1}
            }
            var test1= new Test()
            console.log("test1", test1)//Test {g: 1}

        //----------------------

       
            function test2(params) {
                // this.g = 1
                function name(params) {
                    console.log('test2',this);  // 这个this为啥是window
                }
                name()
                console.log(this);  //
            }
            test2()
            // console.log("test1", test1)

        //----------------------

       
            const a={
                x:()=>{
                    //调用前this是什么,函数里面的this就是什么
                    console.log(this,'x');
                },
                y(){
                    //谁调用this指向谁
                    console.log(this,'y');
                }
            }
            const b=a.x
            const c=a.y
            a.x()  //Window
            a.y() //{x: ƒ, y: ƒ} 'y'     ，a调用指向a

            b()//Window              全局调用
            c()//Window              全局调用

        //----------------------

       
            var o = {
                    a: 10,
                    b: {
                        a: 12,
                        fn: function () {
                            console.log(this.a); // 输出结果是 12
                            console.log(this); // 输出结果是 b 对象
                        }
                    }
                }
                //调用
                o.b.fn();
                var o = {
                    a: 10,
                    b: {
                        fn: function () {
                            console.log(this.a); // undefined
                            console.log(this);   // b对象
                        }
                    }
                }
                //调用
                o.b.fn();
        //----------------------

   
            function foo(something){
                this.a=something
            }
            var obj1={
                foo:foo
            }
            var obj2={}


            obj1.foo(2)

            console.log(obj1.a);   //2

            obj1.foo.call(obj2,3)


            console.log(obj2.a);  //3

            var bar =new obj1.foo(4)

            console.log(obj1.a);    //2

            console.log(bar.a);  //4

            // --------------------------------------
            var a=20;
            function name(params) {
                console.log(a);
                let a   //不存在变量提升  只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

            }
            name()
        //----------------------
        箭头函数中，this 对象的指向是固定的。这种指向的固定化，实际是因为箭头函数根本没有自己的 this ，导致内部的 this 就是外层代码块的 this 。正是因为它没有this，所以也就不能用作构造函数。

        var name = 'window';
        var A = {
            name : 'A',
            show: () => {
                console.log(this.name);
            }
        }
        A.show();　　//window
        如上面代码中的箭头函数，即 show 函数内没有 this，其内部的 this 就是外层代码块的 this，因为没有其他函数的包裹，所以最外层代码块的this指向的就是window对象。所以最后会输出window。
        //----------------------
        那么，怎样改成永远绑定A呢？

        var name = 'window';
        var A = {
            name: 'A',
            show: function() {
                var s = () => console.log(this.name);
                return s;
            }
        }
        var show = A.show();
        show(); //A
        var B = {
            name: 'B'
        }
        show.call(B);   //A
        show.call();    //A
        这样就做到了永远指向 A 对象，我们再来分析一下：

        原代码中 show 即是箭头函数，没有自己的 this；修改之后的代码中，箭头函数所在的作用域是在 show 函数内，show 是普通函数，有自己的 this，在函数调用时生效。A.show() 指向的对象是 A。所以箭头函数 s 中的 this 就是指向 A 了。
    ```




### 六 总结

一 let  
    1 不存在变量提升
    2 不允许重复声明
    3 存在暂时性死区
    4 只在声明的变量所在的代码块内有效
    5 在全局声明 不会被添加到 window 对象中
    6 可以不立即 赋值，可以更改其值
二 const
    1 不存在变量提升
    2 不允许重复声明
    3 存在暂时性死区
    4 只在声明的变量所在的代码块内有效
    5 在全局声明 不会被添加到 window 对象中
    6 一旦声明必须赋值,不能使用null占位
    7 声明的是简单类型数据，不可以修改其值，声明的是复合类型数据，可以修改其属性

三 var
    1 存在变量提升
    2 允许重复声明，后边的回覆盖前边的
    3 无论声明在何处，都会被提至其所在作用于的顶部
    4 全局级别（在函数外部）进行声明都会自动成为 window 对象上的一个属性

var命令和function命令声明的全局变量，依旧是顶层对象的属性，let命令、const命令、class命令声明的全局变量，
不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。


 1 let
        （1）作用域是块级作用域（在ES6之前，js只存在函数作用域以及全局作用域）
            if(1){
                let a=1;
                console.log(a)
            }
        (2)不存在变量声明提前；
            console.log(b); //ReferenceError: b is not defined
            let b=2;

        (3) 不能重复定义

            let a=1;
            let a=2;

            console.log(a);//Identifier 'a' has already been declared

        (4)存在暂时性死区：可以这样来理解

            var a=1；
            if(1){
                console.log(a);
                let a=2;
            }
        5 window 上无法访问
    2 const
        const一般用来声明常量，
        且声明的常量是不允许改变的，只读属性，
        因此就要在声明的同时赋值。
        const与let一样，都是块级作用域，
        存在暂时性死区，
        不存在变量声明提前，
        不允许重复定义   const A=1；（重新给常量A赋值会报错 ）A=3;// Uncaught TypeError: Assignment to constant variable.(错误：赋值给常量)
        window 上无法访问
    3  var
        <!-- https://blog.csdn.net/xiaotiantian1993s/article/details/83992140 -->
        <!-- 箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 -->


[ES6学习笔记之 this 详解 ](https://www.cnblogs.com/ly2019/p/11006188.html)