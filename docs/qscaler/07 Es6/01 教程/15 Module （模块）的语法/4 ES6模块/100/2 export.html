<!--
 * @Author              : qxp
 * @Date                : 2021-10-19 16:02:41
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-10-19 16:38:34
 * @FilePath            : \new\6 Es6\15 Module （模块）的语法\4 ES6模块\2 export.html
-->
 按需导出 
1 直接变量形式
<script>
    // profile.js
    export var firstName = 'Michael';
    export var lastName = 'Jackson';
    export var year = 1958;

    import { firstName, lastName , year} from "./profile.js";

    import * as info from "./profile.js";//通过*来批量接收，as 来指定接收的名字
    console.log(info.firstName);//Michael
    console.log(info.lastName);//Jackson
</script>

2 对象形式  (多个变量可以将这些变量包装成对象)
<script>
    // profile.js
    var firstName = 'Michael';
    var lastName = 'Jackson';
    var obj = {
        test:1,
        tes2:2
    };
    var year = 1958;

    export { firstName, lastName, obj };

    // import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。
    import { firstName, lastName, obj } from "./profile.js";

    firstName = {}; // Syntax Error : 'firstName' is read-only;  // import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。
    obj= { //上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。
        test: 1,
        tes2: 2,
        tes3: 3,
    };
</script>

3 函数形式
<script>
    export function multiply(x, y) {
        return x * y;
    };
    // ------------------------------------
    function v1() { }
    function v2() { }
    export {
        v1 as streamV1,
        v2 as streamV2,
        v2 as streamLatestVersion
    };

     import { streamV1, streamLatestVersion } from "./profile.js";
    // ------------------------------------
    // 报错
    function f() { }
    export f;

    // 正确
    export function f() { };

    // 正确
    function f() { }
    export { f };
</script>

4 默认导出（default export）
    4.1 一个模块只能有一个默认导出，对于默认导出，导入的名称可以和导出的名称不一致。
    <script>
        /******************************导出**********************/
        export default function () {
            return "默认导出一个方法"
        }
        /******************************引入**********************/
        import myFn from "./test.js";//注意这里默认导出不需要用{}。
        // 使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。而用export default命令就可以为模块指定默认输出。import命令不需要加大括号。
        // 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字

        console.log(myFn());//默认导出一个方法
    </script>

    <script>
        /******************************导出**********************/
        export default {
            myFn() {
                return "默认导出一个方法"
            },
            myName: "laowang"
        }
        /******************************引入**********************/
        import myObj from "./test.js";
        console.log(myObj.myFn(), myObj.myName);//默认导出一个方法 laowang
    </script>

    4.2 混合导出
    <script>
        /******************************导出**********************/
        export default function () {
            return "默认导出一个方法"
        }
        export var myName = "laowang";
        /******************************引入**********************/
        import myFn, { myName } from "./test.js";
        console.log(myFn(), myName);//默认导出一个方法 laowang
    </script>

    <script>
        // 相当于输出default变量，这个语句将a的值给了default变量
        let a = 1;
        export default a;
        export var b='foo'
        export var c='bar'

        import a, { b, c } from './a';
    </script>




5 重命名export和import

    如果导入的多个文件中，变量名字相同，即会产生命名冲突的问题，为了解决该问题，ES6为提供了重命名的方法，当你在导入名称时可以这样做：
    <script>

        /******************************test1.js**********************/
        export let myName = "我来自test1.js";
        /******************************test2.js**********************/
        export let myName = "我来自test2.js";
        /******************************index.js**********************/
        import { myName as name1 } from "./test1.js";
        import { myName as name2 } from "./test2.js";
        console.log(name1);//我来自test1.js
        console.log(name2);//我来自test1.js
    </script>













4 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。
<script>

    // 报错
    export 1;

    // 报错
    var m = 1;
    export m;
    // 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。

    // 写法一
    export var m = 1;

    // 写法二
    var m = 1;
    export { m };

    // 写法三
    var n = 1;
    export { n as m };
</script>

4 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

<script>
    // a.js
    export var foo = 'bar';
    setTimeout(() => foo = 'baz', 500);

    // b.js

    import  a from './a.js'
    console.log("🚀 ~ file: 2.html ~ line 86 ~ a", a)  //上面代码输出变量foo，值为bar，500 毫秒之后变成baz。
    
</script>