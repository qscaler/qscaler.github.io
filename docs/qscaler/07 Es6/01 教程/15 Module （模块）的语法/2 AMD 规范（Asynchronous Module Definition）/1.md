<!--
 * @Author              : qxp
 * @Date                : 2021-09-29 15:01:58
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-09-29 15:40:06
 * @FilePath            : \new\6 Es6\15 Module （模块）的语法\2 AMD 规范（Asynchronous Module Definition）\1.html
-->

[模块化之 AMD 与 CMD 原理(附源码) -------------------清晰-------------------------](https://juejin.cn/post/6844903759009595405#heading-9)

### AMD (Asynchronous Module Definition)定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题

1.  AMD 对应的就是很有名的 RequireJS。
    (AMD 规范的实现方式是 RequireJS) 从名字上可以看出，它主要提供了异步加载的功能,其思想就是把代码分为一个一个的模块来分块加载，这样无疑可以提高代码的重用

    **AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块**对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS **从 2.0 开始，也改成可以延迟执行**（根据写法不同，处理方式不同）

2.  AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。
    比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。
    requireJS 主要解决两个问题
    多个 js 文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
    js 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长

    链接：https://www.zhihu.com/question/20351507/answer/14859415

3.  在整个 require 中，主要的方法就两个：require 和 define

    ```js
    // define(id ?, dependencies ?, factory);

    // id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）
    // dependencies：是一个当前模块依赖的模块名称数组,如果没有指定 dependencies，那么它的默认值是 ["require", "exports", "module"]。
    // factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值

    // 定义模块 myModule.js
    //  requireJS定义了一个函数 define，它是全局变量，用来定义模块

    define(function (require, exports, module) {})

    // 在模块定义内部引用依赖： amd的cmd写法
    define(function (require) {
        var $ = require('jquery')
        $('body').text('hello world')
    })

    define(['jquery'], function ($) {
        $('body').text('hello world')
    })

    define('myModule', ['jquery'], function ($) {
        // $ 是 jquery 模块的输出
        $('body').text('hello world')
    })

    // 注意：在 webpack 中，模块名只有局部作用域，在 Require.js 中模块名是全局作用域，可以在全局引用。
    // 依赖多个模块的定义：
    define(['jquery', './math.js'], function ($, math) {
        // $ 和 math 一次传入 factory
        $('body').text('hello world')
    })

    // require([dependencies], function () { });
    // require()函数接受两个参数 *
    //     第一个参数是一个数组，表示所依赖的模块
    //     第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块
    //     require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。

    // 在页面上使用require函数加载模块
    require(['myModule'], function (myModule) {
        myModule.printName()
    })
    ```

4.  文件加载、 模块运行顺序  
    文件加载/文件运行 顺序： 1.js , 2.js , 3.js
    模块运行 顺序：3.js , 2.js , 1.js
