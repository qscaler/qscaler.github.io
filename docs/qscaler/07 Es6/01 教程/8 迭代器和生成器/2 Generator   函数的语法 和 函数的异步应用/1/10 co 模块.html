<!--
 * @Author              : qxp
 * @Date                : 2021-03-26 11:24:30
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-03-26 11:31:42
 * @FilePath            : \new\6 Es6\12 Generator 函数的语法\10 co 模块.html
-->
co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。

下面是一个 Generator 函数，用于依次读取两个文件。

https://es6.ruanyifeng.com/#docs/generator-async
<script>
    var gen = function* () {
        var f1 = yield readFile('/etc/fstab');
        var f2 = yield readFile('/etc/shells');
        console.log(f1.toString());
        console.log(f2.toString());
    };
</script>
co 模块可以让你不用编写 Generator 函数的执行器。
<script>
    var co = require('co');
    co(gen);
</script>
上面代码中，Generator 函数只要传入co函数，就会自动执行。
co函数返回一个Promise对象，因此可以用then方法添加回调函数。
<script>
    co(gen).then(function () {
        console.log('Generator 函数执行完成');
    });
</script>
上面代码中，等到 Generator 函数执行结束，就会输出一行提示。
两种方法可以做到这一点。

（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。

（2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。

co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise
对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。

上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。

<script>
    var fs = require('fs');
    var readFile = function (fileName) {
        return new Promise(function (resolve, reject) {
            fs.readFile(fileName, function (error, data) {
                if (error) return reject(error);
                resolve(data);
            });
        });
    };
    var gen = function* () {
        var f1 = yield readFile('/etc/fstab');
        var f2 = yield readFile('/etc/shells');
        console.log(f1.toString());
        console.log(f2.toString());
    };
    // 然后，手动执行上面的 Generator 函数。
    var g = gen();
    g.next().value.then(function (data) {
        g.next(data).value.then(function (data) {
            g.next(data);
        });
    });

    // 手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。
    function run(gen) {
        var g = gen();
        function next(data) {
            var result = g.next(data);
            if (result.done) return result.value;
            result.value.then(function (data) {
                next(data);
            });
        }

        next();
    }

    run(gen);
</script>

<script>
    function co(gen) {
        var ctx = this;
        return new Promise(function (resolve, reject) {
            if (typeof gen === 'function') gen = gen.call(ctx);
            if (!gen || typeof gen.next !== 'function') return resolve(gen);

            onFulfilled();
            function onFulfilled(res) {
                var ret;
                try {
                    ret = gen.next(res);
                } catch (e) {
                    return reject(e);
                }
                next(ret);
            }
        });
    }
    // 最后，就是关键的next函数，它会反复调用自身。
    function next(ret) {
        if (ret.done) return resolve(ret.value);
        var value = toPromise.call(ctx, ret.value);
        if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
        return onRejected(
            new TypeError(
                'You may only yield a function, promise, generator, array, or object, '
                + 'but the following object was passed: "'
                + String(ret.value)
                + '"'
            )
        );
    }
</script>