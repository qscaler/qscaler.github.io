<!--
 * @Author              : qxp
 * @Date                : 2021-03-25 16:45:28
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-03-26 11:03:35
 * @FilePath            : \new\6 Es6\12 Generator 函数的语法\9 Generator 函数的this.html
-->
Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。

<script>
    function* g() { }

    g.prototype.hello = function () {
        return 'hi!';
    };

    let obj = g();   //ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法

    obj instanceof g // true
    obj.hello() // 'hi!'
</script>
上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。
但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。
<script>
    function* g() {
        this.a = 11;
    }

    let obj = g();
    obj.next();
    obj.a // undefined
</script>
上面代码中，Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。

Generator 函数也不能跟new命令一起用，会报错。
<script>
    function* F() {
        yield this.x = 2;
        yield this.y = 3;
    }

    new F()
// TypeError: F is not a constructor
</script>
上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。


那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？

下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。

<script>
    function* F() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
    }
    var obj = {};
    var f = F.call(obj);

    f.next(); // Object {value: 2, done: false}
    f.next(); // Object {value: 3, done: false}
    f.next(); // Object {value: undefined, done: true}

    obj.a // 1
    obj.b // 2
    obj.c // 3
</script>
上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次next方法（因为F内部有两个yield表达式），完成 F
内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。

上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？

一个办法就是将obj换成F.prototype。

<script>
    function* F() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
    }
    var f = F.call(F.prototype);

    f.next(); // Object {value: 2, done: false}
    f.next(); // Object {value: 3, done: false}
    f.next(); // Object {value: undefined, done: true}

    f.a // 1
    f.b // 2
    f.c // 3
</script>
再将F改成构造函数，就可以对它执行new命令了。

<script>
    function* gen() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
    }

    function F() {
        return gen.call(gen.prototype);
    }

    var f = new F();

    f.next(); // Object {value: 2, done: false}
    f.next(); // Object {value: 3, done: false}
    f.next(); // Object {value: undefined, done: true}

    f.a // 1
    f.b // 2
    f.c // 3
</script>

<script>
    function* gen() {
        yield 1;
        return 2;
    }

    let g = gen();

    console.log(
        g.next().value,
        g.next().value,
        g.next().value,
    );
    //1
    //2
    //undefined
</script>
（1）异步操作的同步化表达
<script>
    function* main() {
        var result = yield request("http://some.url");
        var resp = JSON.parse(result);
        console.log(resp.value);
    }

    function request(url) {
        makeAjaxCall(url, function (response) {
            it.next(response);
        });
    }
    var it = main();
    it.next();
    // 注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。

</script>

(2)控制流管理
<script>
    function* longRunningTask(value1) {
        try {
            var value2 = yield step1(value1);
            var value3 = yield step2(value2);
            var value4 = yield step3(value3);
            var value5 = yield step4(value4);
            // Do something with value4
        } catch (e) {
            // Handle any error from step1 through step4
        }
    }
    // 然后，使用一个函数，按次序自动执行所有步骤。

    scheduler(longRunningTask(initialValue));

    function scheduler(task) {
        var taskObj = task.next(task.value);
        // 如果Generator函数未结束，就继续调用
        if (!taskObj.done) {
            task.value = taskObj.value
            scheduler(task);
        }
    }
    // 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。
    // 因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。
</script>

