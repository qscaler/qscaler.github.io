<!--
 * @Author              : qxp
 * @Date                : 2021-03-25 11:43:20
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-03-25 15:42:08
 * @FilePath            : \new\6 Es6\12 Generator 函数的语法\1 .html
-->

Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。

执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，
还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

<script>
    function* gen(x) {
        var y = yield x + 2;
        return y;
    }
    var g = gen(1);
    g.next() // { value: 3, done: false }
    g.next() // { value: undefined, done: true }
</script>
上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，
即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next
方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。

换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。
value 属性是 yield语句后面表达式的值，表示当前阶段的值；
done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。

<script>
    function* gen(x) {
        var y = yield x + 2;
        return y;
    }

    var g = gen(1);
    g.next() // { value: 3, done: false }
    g.next(2) // { value: 2, done: true }
        // 上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。
        // 第二个 next 方法带有参数2，这个参数可以传入 Generator 函数，
        // 作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是2（变量 y 的值）。
</script>


然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator
函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。
必须调用遍历器对象的next方法，使得指针移向下一个状态
每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，
Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。

<script>
    function* helloWorldGenerator() {
        yield 'hello';
        yield 'world';
        return 'ending';
    }
    var hw = helloWorldGenerator();
    hw.next()// { value: 'hello', done: false }
    hw.next() // { value: 'world', done: false }
    hw.next() // { value: 'ending', done: true }
    hw.next()// { value: undefined, done: true }
</script>