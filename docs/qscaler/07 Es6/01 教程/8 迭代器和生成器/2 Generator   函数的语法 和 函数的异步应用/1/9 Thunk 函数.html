<!--
 * @Author              : qxp
 * @Date                : 2021-03-26 11:03:52
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-03-26 11:24:07
 * @FilePath            : \new\6 Es6\12 Generator 函数的语法\9 Thunk 函数.html
-->
4 Thunk 函数
Thunk 函数是自动执行 Generator 函数的一种方法
<script>
    // 下面是另一个完整的例子。
    function f(a, cb) {
        cb(a);
    }
    const ft = Thunk(f);

    ft(1)(console.log) // 1
</script>
5 Generator 函数的流程管理
你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，
Thunk 函数现在可以用于 Generator 函数的自动流程管理。

Generator 函数可以自动执行。
<script>
    function* gen() {
        // ...
    }

    var g = gen();
    var res = g.next();

    while (!res.done) {
        console.log(res.value);
        res = g.next();
    }
</script>
上面代码中，Generator 函数gen会自动执行完所有步骤。

但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。
这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。
<script>
    var fs = require('fs');
    var thunkify = require('thunkify');
    var readFileThunk = thunkify(fs.readFile);

    var gen = function* () {
        var r1 = yield readFileThunk('/etc/fstab');
        console.log(r1.toString());
        var r2 = yield readFileThunk('/etc/shells');
        console.log(r2.toString());
    };
    // 手动执行
    var g = gen();
    var r1 = g.next();
    r1.value(function (err, data) {
        if (err) throw err;
        var r2 = g.next(data);
        r2.value(function (err, data) {
            if (err) throw err;
            g.next(data);
        });
    });
    // 可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。
</script>


Thunk 函数的自动流程管理
Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。

<script>
    function run(fn) {
        var gen = fn();
        function next(err, data) {
            var result = gen.next(data);
            if (result.done) return;
            result.value(next);
        }

        next();
    }

    function* g() {
        // ...
    }

    run(g);
</script>

上面代码的run函数，就是一个 Generator 函数的自动执行器。内部的next函数就是 Thunk 的回调函数
。next函数先将指针移到 Generator 函数的下一步（gen.next方法），然后判断 Generator
函数是否结束（result.done属性），如果没结束，就将next函数再传入 Thunk 函数（result.value属性），否则就直接退出。

有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，
直接把 Generator 函数传入run函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在yield命令后面的必须是 Thunk
函数。

<script>
    var g = function* () {
        var f1 = yield readFileThunk('fileA');
        var f2 = yield readFileThunk('fileB');
        // ...
        var fn = yield readFileThunk('fileN');
    };
    run(g);

</script>
上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。
这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。

Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，
自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。