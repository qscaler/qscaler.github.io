<!--
 * @Author              : qxp
 * @Date                : 2021-03-26 11:40:44
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-10-08 17:39:06
 * @FilePath            : \new\6 Es6\8  迭代器\3 async  await函数\2 await .html
-->
正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。
另一种情况是，await命令后面是一个thenable对象（即定义了then方法的对象），那么await会将其等同于 Promise 对象。
<script>
    async function f() {
        // 等同于
        // return 123;
        return await 123;
    }

    f().then(v => console.log(v))
// 123F
</script>

await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。
<script>
    async function f() {
        await Promise.reject('出错了');
    }
    f().then(v => console.log(v)).catch(e => console.log(e))
    // 出错了
</script>
注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。
这里如果在await前面加上return，效果是一样的。

任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。
<script>
    async function f() {
        await Promise.reject('出错了');
        await Promise.resolve('hello world'); // 不会执行
    }
</script>

有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，
这样不管这个异步操作是否成功，第二个await都会执行。

<script>
    async function f() {
        try {
            await Promise.reject('出错了');
        } catch (e) {
        }
        return await Promise.resolve('hello world');
    }
    f().then(v => console.log(v))
    // hello world
</script>
或者

<script>
    function To(promise) {
        // return promise.then(data => [data]).catch(err => [err, null]);
        return promise.then(resp => [null, resp]).catch(err => [err, null]);
        // return promise.then(resp => [resp]);
    }
    async function f() {
        const [resp, err] = await To(Promise.reject('出错了'));
        // ...
    }
    f()
</script>
或者

<script>
    async function f() {
        await Promise.reject('出错了').catch(e => console.log(e));
        return await Promise.resolve('hello world');
    }

    f().then(v => console.log(v))
    // 出错了
</script>
<script>
    async function main() {
        try {
            const val1 = await firstStep();
            const val2 = await secondStep(val1);
            const val3 = await thirdStep(val1, val2);

            console.log('Final: ', val3);
        }
        catch (err) {
            console.error(err);
        }
    }
</script>


<script>
    export function To(promise) {
        return promise.then(resp => [null, resp]).catch(err => [err, null]);
    }
    
    const request = axios.create({ })

    function getData(params) {
        return request({
            url: '/supply/param/getCalculationParamData',
            method: 'get',
            params: params
        })
    }

    async function getCalculationParamData() {
        const [err, resp] = await To(getData())
        if (err) {
            return
        }
        if (resp.code == 200) {

        }
    }
</script>