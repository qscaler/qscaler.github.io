<!--
 * @Author              : qxp
 * @Date                : 2021-06-22 13:21:47
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-10-19 12:29:41
 * @FilePath            : \new\6 Es6\14 Class 的基本语法\1.1箭头.html
-->
<script>
    class App {
        constructor() {
            this.handleClick = () => {
                console.log('this is:', this);
            }
        }
        handleClick1 = () => { // 2  如果方法是箭头函数方法，该方法会绑定在构造函数上；
            console.log('this is:', this);
        }
        handleClick2() { // 1  class中的方法如果是普通函数方法，该方法会绑定在构造函数的原型上；
            console.log('this is:', this);
        }

    }
    // 等同于
    function App() {
        this.handleClick = () => {
            console.log('this is:', this);
        };
        this.handleClick1 = () => {
            console.log('this is:', this);
        }
    }
    App.prototype.handleClick2 = function () {
        console.log('this is:', this)
    }

    const app = new App();
    app.handleClick();//this is: App { handleClick: [Function] }
    app.handleClick1();//会报错  ？？？？//  谷歌浏览器没报错
    app.handleClick2();//this is: App { handleClick: [Function] }解释一下：

    console.log(Object.keys(app));   // ["handleClick1", "handleClick"]

    // hasOwnProperty()函数用于判断属性是否是实例属性
    console.log(app.hasOwnProperty("handleClick"));//true   
    console.log(app.hasOwnProperty("handleClick1"));//true
    console.log(app.hasOwnProperty("handleClick2"));//false

    let handleClick1 = app.handleClick1;
    let handleClick2 = app.handleClick2;
    handleClick1();     // App
    handleClick2();     // undefined

    // 3  通过上述方式调用class中的方法，无论是箭头函数方法还是普通函数方法，方法中的this都指向实例对象。

    // 通过引用来调用箭头函数方法，方法中的this依然指向创建的实例对象。
    // 原因：箭头函数中的this，只和定义该箭头函数的位置有关系，即，箭头函数中的this始终是该箭头函数所在作用域中的this。而箭头函数所在的作用域中的this指向foo实例对象。
    // 通过引用调用普通函数方法，方法中的this会指向undefined。
    // 原因：因为普通函数中的this是动态绑定的，始终指向函数的执行环境，上面的例子中在全局环境中调用getAge方法，但是this却是undefined而不是window。
    // 原因在于class声明和class表达式中会默认使用严格模式

    // ————————————————
    // 原文链接：https://blog.csdn.net/qq_36968599/article/details/114341210
</script>
https://www.zhihu.com/question/59025982

<script>
    // 链接：https://www.zhihu.com/question/59025982/answer/161252744

    // 很显然第一个写法是非法的。题目标签里面有 React, 所以且认为这段代码是题主在 React 组件（ES6 Class）中截取出来的一部分。
    // 首先是希望题主（以及众多的其他题主）注意提问姿势，不要惜墨如金藏头藏尾，叫别人去猜你要问什么。那么这个问题的完整描述应该是：
    class App extends Component {
        a() {
            console.log(1)
        }

        a = () => {
            console.log(1)
        }
    }
    // 里面的两个 a 的定义有什么区别？第一个 a 不必说，是原型方法的定义。宽松模式下对应 ES5 就是
    App.prototype.a = function () { }
    // 第二个是 Stage 2 Public Class Fields 里面的写法，babel 下需要用 Class properties transform Plugin 进行转义。相当于：
    class App extends Component {
        constructor(...args) {
            super(...args)
            this.a = () => {
                console.log(1)
            }
        }
    }
    // 为什么需要第二种写法？在 React 里面，要将类的原型方法通过 props 传给子组件，传统写法需要 bind(this) ，
    // 否则方法执行时 this 会找不到：
    // <button onClick={this.handleClick.bind(this)}></button>
    // 或者
    // < button onClick = {(e) => this.handleClick(e)}></ >
    //  这种写法难看不说，还会对 React 组件的 shouldComponentUpdate 优化造成影响。
    //  这是因为 React 提供了 shouldComponentUpdate 让开发者能够控制避免不必要的 render，还提供了在 shouldComponentUpdate 自动进行 
    //   Shallow Compare 的 React.PureComponent, 继承自 PureComponent 的组件只要 props 和 state 中的值不变，组件就不会重新 render。
    //   然而如果用了 bind this，每次父组件渲染，传给子组件的 props.onClick 都会变，PureComponent 的 Shallow Compare 基本上就失效了，
    //   除非你手动实现 shouldComponentUpdate.使用 Public Class Fields 的这种写法，就解决了这个问题。另外还有其他若干种办法，比如先定义原型方法，
    //   然后在 constructor 里面 bind 一遍；或者使用 decorator 进行 bind 等：
    class A {
        constructor() {
            this.a = this.a.bind(this)
        }

        a() { }

        // or
        // @bindthis
        b() { }
    }
</script>

<script>
    class Foo extends React.Component {
        constructor(super) {
            //this.a = this.a.bind(this) // 老写法
        }
        a(val) {
            console.log(val);
        }
        b = () => {
            console.log(1);
        }
        render(){
            return (
                <div>
                    <div onClick={this.a.bind(this)}></div> // 老写法
                    <div onClick={this.a.bind(this,'100')}></div> // 老写法
                    <div onClick={this.b}></div> // 新写法
                </div>
            )
        }
    }

</script>