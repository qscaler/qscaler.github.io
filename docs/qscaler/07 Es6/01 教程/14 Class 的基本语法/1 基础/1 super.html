<!--
 * @Author              : qxp
 * @Date                : 2021-03-15 14:49:12
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-06-22 14:10:15
 * @FilePath            : \new\6 Es6\1 constructor.html\1 super.html
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    链接：https://www.jianshu.com/p/fc79756b1dc0
    <script>
        // super 这个关键字，既可以当做函数使用，也可以当做对象使用。这两种情况下，它的用法完全不用。
        // 1. 当做函数使用
            class A { }
            class B extends A {
                constructor() {
                    super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。
                }
            }
            // 注：在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的  this 对象，
            // 然后对其进行加工, 而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，
            // 即 super 内部的 this 指的是 B，因此 super() 在这里相当于```A.prototype.constructor.call(this, props)``。
            class C {
                constructor() {
                    console.log(new.target); // new.target 指向当前正在执行的函数
                }
            }

            class D extends C {
                constructor() {
                    super();
                }
            }

            new C(); // C
            new D(); // D
            // 可以看到，在 super() 执行时，它指向的是 子类 D 的构造函数，而不是父类 C 的构造函数。也就是说，super() 内部的 this 指向的是 D。
        // 2. 当做对象使用
            //  1 在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
            class E {
                c() {
                    return 2;
                }
            }

            class F extends E {
                constructor() {
                    super();
                    console.log(super.c()); // 2  E.prototype.c()
                }
            }
            let b = new F();
            // 上面代码中，子类 F 当中的 super.c() ，就是将 super 当作一个对象使用。这时，super 在普通方法之中，
            // 指向 E.prototype，所以 super.c() 就相当于 E.prototype.c() 。

            // -----------------------------------------------------------------------------------------------------

            // 2 通过 super 调用父类的方法时，super 会绑定子类的 this。
            class A {
                constructor() {
                    this.x = 1;
                }
                s() {
                    console.log(this.x);
                }
                #aa=22;
                w() {
                    console.log(this.#aa);
                }
                #p = 33;
                getP() {
                    return this.#p;
                }
                            }

            class B extends A {
                constructor() {
                    super();
                    this.x = 44;
                    console.log(this.s());//44
                    console.log(this.w());//22
                    console.log(this.getP());//33
                }
                m() {
                    super.s();  //A.prototype.s().bind(this)
                }
            }

            let b = new B();
            b.m(); // 44
            // 上面代码中，super.s() 虽然调用的是 A.prototytpe.s() ，但是 A.prototytpe.s()会绑定子类 B 的 this，导致输出的是 44，而不是 1。
            // 也就是说，实际上执行的是 super.s.call(this) 。
            // -----------------------------------------------------------------------------------------------------
            // 3 由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性。

            class A {
                constructor() {
                    this.x = 1;
                }
            }

            //  ?????
            // 这个地方确实很难理解。只能理解为，规格的硬性规定，读操作和写操作不是同一个对象。读操作时，super 是子类的原型，写操作时super是子类的实例。
            class B extends A {
                constructor() {
                    super();
                    this.x = 2;
                    super.x = 3;
                    console.log(super.x); // undefined
                    console.log(this.x); // 3
                }
            }

            let b = new B();
            // 上面代码中，super.x 赋值为 3，这时等同于对 this.x 赋值为 3。而当读取 super.x 的时候，调用的是 A.prototype.x，
            // 但并没有 x 方法，所以返回 undefined。
            // -----------------------------------------------------------------------------------------------------
            // 4 注意，使用 super 的时候，必须显式指定是作为函数，还是作为对象使用，否则会报错。

            class A {
                constructor() {
                    this.x = 1;
                }
                s() {
                    console.log(this.x);
                }
            }
            class B extends A {
                constructor() {
                    super();   //作为函数使用
                    this.x = 2;
                    console.log(super); // 报错
                    console.log(super.s()); // 2  当做对象使用
                }
                m() {
                    super.s(); // 2  当做对象使用
                }
            }
            // 上面代码中，console.log(super); 的当中的 super，无法看出是作为函数使用，还是作为对象使用，
            // 所以 JavaScript 引擎解析代码的时候就会报错。这是，如果能清晰的表明 super 的数据类型，就不会报错。

            // 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字。

            // 结语：
            // ES6 的 class 毕竟是一个“语法糖”，所以只要理解了 JavaScript 中对象的概念和面向对象的思想，class 就不难理解啦。

          
    </script>
</body>

</html>