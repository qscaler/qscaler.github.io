<!--
 * @Author              : qxp
 * @Date                : 2021-03-26 16:03:13
 * @LastEditors         : Please set LastEditors
 * @LastEditTime        : 2021-03-26 16:20:19
 * @FilePath            : \new\6 Es6\14 Class 的基本语法\1 简介.html
-->
1 类的由来
<script>
    function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    Point.prototype.toString = function () {
        return '(' + this.x + ', ' + this.y + ')';
    };

    var p = new Point(1, 2);
</script>

2 ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，
新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。
<script>
    class Point {
        constructor(x, y) {  //可以看到里面有一个constructor()方法，这就是构造方法，而this关键字则代表实例对象
            this.x = x;
            this.y = y;
        }

        //还定义了一个toString()方法。注意，定义toString()方法的时候，前面不需要加上function这个关键字，
        // 直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。
        // 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。

        // 因此，在类的实例上面调用方法，其实就是调用原型上的方法。
        toString() {
            return '(' + this.x + ', ' + this.y + ')';
        }
    }



    class Point {
        constructor() {
            // ...
        }
        toString() {
            // ...
        }
        toValue() {
            // ...
        }
    }

    // 等同于
    Point.prototype = {
        constructor() { },
        toString() { },
        toValue() { },
    };
</script>

3 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
<script>
    // 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
    // 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
    // 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
    class Point {
        constructor(x, y) {
            // ...
        }

        toString() {
            // ...
        }
    }

    Object.keys(Point.prototype)
    // []
    Object.getOwnPropertyNames(Point.prototype)
    // ["constructor","toString"]

    // 上面代码中，toString()方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。


    // Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
    //Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。
    //共同点：都是返回自身的属性，不会返回原型链上的。
    //区别： Object.keys()返回可枚举的，Object.getOwnPropertyNames()返回所有的。



    var Point = function (x, y) {
        // ...
    };

    Point.prototype.toString = function () {
        // ...
    };

    Object.keys(Point.prototype)
    // ["toString"]
    Object.getOwnPropertyNames(Point.prototype)
    // ["constructor","toString"]
    // 上面代码采用 ES5 的写法，toString()方法就是可枚举的。

</script>